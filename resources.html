<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>CSSE 220</title>


<link rel="stylesheet" type="text/css" href="./syllabus_files/screen.css">
<link rel="stylesheet" type="text/css" href="./syllabus_files/schedule.css">
<link rel="icon" type="image/x-icon" href="favicon.ico">
<style>
/* Main content container */
/* Header styling */
#header {
        position: fixed;
        top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
    }
    #header a {
      color: #fff;
      margin-right: 15px;
      text-decoration: none;

    }
    #header a:hover {
      text-decoration: underline;
    }
    #header div {
      clear: both;
    }
    /* Content container */
    #content {
      padding: 20px;
      margin-top: 100px; 
      margin-bottom: 50px;
    }
    h1, h2 {
      
      color: #ffffff;
    }
/* Table of Contents styling */
    .toc {
      background-color: #3a3a3a;
      padding: 10px;
      border-radius: 5px;
      margin-bottom: 20px;
    }
    .toc ul {
      list-style-type: none;
      padding-left: 0;
    }
    .toc li {
      margin-bottom: 5px;
    }
    .toc a {
      color: #61dafb;
      text-decoration: none;
    }
    .toc a:hover {
      text-decoration: underline;
    }
    /* Section styling */
    section {
      margin-bottom: 40px;
    }
    section p, section ul, dl {
      
      font-size: 1em;
      color: black;
      line-height: 1.6;
    }
    section ul {
      list-style-type: disc;
      margin-left: 20px;
    }
    section li {
      margin-bottom: 5px;
    }
    section dl {
      background-color: #21252b;
      padding: 10px;
      border-radius: 5px;
    }
    section dt {
      font-weight: bold;
      margin-top: 10px;
      color: #61dafb;
    }
    section dd {
      margin-left: 20px;
      margin-bottom: 10px;
      font-family: "Courier New", Courier, monospace;
      background-color: #1e1e1e;
      padding: 4px 8px;
      border-radius: 3px;
      display: inline-block;
      color: #dcdcdc;
    }

    section::before {
  content: "";
  display: block;
  height: 90px; /* equal to your header's height */
  margin-top: -90px;
}
    /* Code block styling for loop examples */
    pre {
      background-color: #1e1e1e;
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
    }
    code {
      font-family: "Courier New", Courier, monospace;
      color: #ccc5c5;
      font-size: 0.95em;
    }
    .output {
      background-color: #f5f5f5;
      color: #333;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      overflow-x: auto;
      font-family: "Courier New", Courier, monospace;
      margin-top: 10px;
    }

 #toTop {
    position: fixed;
    right: 20px;
    bottom: 24px;
    padding: 0.55rem 1rem;
    border: none;
    border-radius: 999px;
    background: #111827;          /* near-black gray */
    color: #f9fafb;
    font-weight: 600;
    font-size: 0.9rem;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
    opacity: 0;
    transform: translateY(10px);
    pointer-events: none;
    transition: opacity 0.25s ease, transform 0.25s ease;
    z-index: 1001;
  }
  #toTop.show{ opacity:1; transform:none; pointer-events:auto; }
  #toTop:hover{ filter:brightness(1.1); }
</style>
</head>
<body>
        <div id="header">
            <a id="index_link" href="./index.html">CSSE 220</a>
            <a id="syllabus_link" href="./syllabus.html">Syllabus</a>
            <a id="schedule_link" href="./schedule.html">Schedule</a>
            <a id="quiz_link" href="./worksheets.html">Quizzes</a>
            <a id="quiz_link" href="./labs.html">Labs</a>
            <a id="quiz_link" href="./homework.html">Homework</a>
            <a id="quiz_link" href="./exams.html">Exams</a>
            <a id="quiz_link" href="./project.html">Final Project</a>
            <a id="resources_link" href="./resources.html">Resources</a>
            <div style="clear:both;"></div>
        </div>

<!-- Main Content -->
<div id="content">
    <h1>Resources</h1>
    <!-- Table of Contents -->
    <div class="toc">
      <h2>Table of Contents</h2>
      <dl>
        <p style="color:white">Basics</p>
        <dd><a href="#syntax">Java Syntax</a></dd>
        <dd><a href="#java-types">Primitive Data Types</a></dd>
        <dd><a href="#data-type">How to Determine Data Types</a></dd>
        <dd><a href="#instanceof">Instance Of</a></dd>
        <dd><a href="#operators">Operators</a></dd>
        <dd><a href="#loops">Loops</a></dd>
        <dd><a href="#printf">Print Formatting</a></dd>
        <dd><a href="#conditionals">Conditionals</a></dd>
        <dd><a href="#switch-cases">How to use switch cases</a></dd>
        <dd><a href="#string-methods">String, Length, Substring</a></dd>
        <dd><a href="#int-to-string">Converting Between Integers, Strings, and Characters</a></dd>
        <dd><a href="#casting">Casting</a></dd>
        <dd><a href="#arrays">Arrays</a></dd>
        <dd><a href="#arrays">Array Lists</a></dd>
        <dd><a href="#hashmap">HasMaps</a></dd>
        <dd><a href="#size">Length vs Size</a></dd>
        <dd><a href="#heterogeneous">Heterogeneous Array List</a></dd>
        <dd><a href="#math">Math Library</a></dd>
        <dd><a href="#javadoc">Understanding Javadocs</a></dd>
        <dd><a href="#scanner">How to Use Scanner</a></dd>
        <dd><a href="#recursion">Recursion</a></dd>

        <p style="color:white">Classes And Methods</p>
        <dd><a href="#return">Void, Return, Calling Methods</a></dd>
        <dd><a href="#fields">Understanding Fields in Classes</a></dd>
        <dd><a href="#static">Understanding Static Modifier</a></dd>
        <dd><a href="#this-keyword">Understanding This Keyword</a></dd>
        <dd><a href="#initialization">Understanding Initialization</a></dd>
        <dd><a href="#uml-rules">Understanding UML Models</a></dd>

        <p style="color:white">Polymorphism</p>
        <dd><a href="#abstract">Abstract Classes</a></dd>
        <dd><a href="#interface">Interfaces</a></dd>
        <dd><a href="#upcast">Upcasting and Downcasting</a></dd>
        <dd><a href="#illegalcast">How Determine if Cast is Illegal</a></dd>
        <dd><a href="#errors">Compile and Run-Time Errors</a></dd>
        <dd><a href="#junit">How to create JUnit Tests</a></dd>
        <dd><a href="#files">reading and Writing Files</a></dd>

        <p style="color:white"> Graphics</p>
        <dd><a href="#jframe">Making JFrame</a></dd>
        <dd><a href="#painting">Paint Components: JPanel, JComponent</a></dd>
        <dd><a href="#threads">Swing Threads</a></dd>
        <dd><a href="#swing-timer">Swing Timer</a></dd>
        <dd><a href="#animation">Basic Animation Loop</a></dd>
        <dd><a href="#swing">Basics Swing Graphics</a></dd>
        <dd><a href="#swinggraphics">Swing Graphics with paintComponent</a></dd>
        <dd><a href="#transform">Graphics Transform</a></dd>
        <dd><a href="#events">Event Handling</a></dd>
        <dd><a href="#listener">Understanding ActionListener</a></dd>
        <dd><a href="#images">Images in Java</a></dd>
        <dd><a href="#focus">Keeping focus for events</a></dd>
        <dd><a href="#screens">Making Multiple Screens</a></dd>
        <dd><a href="#levels">Using multiple levels</a></dd>
        <dd><a href="#sprites">Loading sprites as static properties</a></dd>

        
        
        
        
        
        
        <!-- Future sections can be added here -->
      </dl>
    </div>
 <!-- Syntax Section -->
    <section id="syntax">
        <h1 style="color:black">Basic Java Class Structure</h1>
        <p>
          Every Java program begins with a <strong>class declaration</strong>. 
          By convention, class names use <strong>PascalCase</strong> (each word capitalized) and 
          the file name should match the class name.
        </p>
        <p>
          A basic Java program must include a <strong><code style="color:black">public static void main(String[] args)</code></strong> method. This <strong><em>main method</em></strong> 
          is the entry point for execution.
        </p>
        <pre><code>public class HelloWorld {
    public static void main(String[] args) {
            // Print a simple message to the console
            System.out.println("Hello, world!");
    }
}</code></pre>
        <p>
          To run this program in Eclipse, 
          simply create a new Java project, 
          add this class to your <strong><code style="color:black">src</code></strong> folder, 
          right-click on the file, and 
          select <strong>Run As &gt; Java Application</strong>.
        </p>
        <p>
            <strong>Variables</strong> should be named using 
            <strong>camelCase</strong> notation (the first letter is lowercase and subsequent words start with a capital letter). 
            Every variable must be <em>declared</em> with a type and <em>initialized</em> before use. 
            For example, you can declare and initialize a variable and then print its value as follows:
          </p>
          <pre><code>int myNumber = 42;
System.out.println("The number is: " + myNumber);</code></pre>
          <p>
            In this example, the integer variable <strong><code style="color:black">myNumber</code></strong> is declared and initialized with the value <strong><code style="color:black">42</code></strong>, and its value is printed using <strong><code style="color:black">System.out.println()</code></strong>.
          </p>
      </section>

    <!-- Data Types Section -->
    <section id="java-types">
      <h1 style="color:black">Data Types</h1>
      <p>
        Java provides eight primitive data types that serve as the building blocks for data manipulation.
      </p>
      <dl>
        <dt>byte</dt>
        <dd><code>byte b = 100;</code></dd>
        <dt>short</dt>
        <dd><code>short s = 32000;</code></dd>
        <dt>int</dt>
        <dd><code>int x = 5;</code></dd>
        <dt>long</dt>
        <dd><code>long l = 1000000L;</code></dd>
        <dt>float</dt>
        <dd><code>float f = 3.14f;</code></dd>
        <dt>double</dt>
        <dd><code>double d = 3.14159;</code></dd>
        <dt>boolean</dt>
        <dd><code>boolean flag = true;</code></dd>
        <dt>char</dt>
        <dd><code>char c = 'A';</code></dd>
      </dl>
      <p>
        In addition to these primitive types, Java uses the <strong>String</strong> class to represent sequences of characters. Strings are objects, not primitives, and are immutable, meaning once created their values cannot be changed. They provide a wide array of methods for 
        string manipulation such as concatenation, substring extraction, and searching.
      </p>
    <dl>
      <dt>String</dt>
      <dd><code>String s = "Hello";</code></dd>
    </dl>
    </section>
<!-- Java Operators Section -->
<section id="operators">
    <h1 style="color:black">Java Operators: Math, Logical &amp; Comparison </h1>
    <p>Java operators perform arithmetic calculations and evaluate logical conditions. Use math operators for numerical computations and logical operators for combining boolean expressions.</p>
    
    <h3>Math Operators</h3>
    <p>Math operators are used for basic arithmetic: addition (+), subtraction (-), 
        multiplication (*), division (/), and modulus (%).</p>
    <pre><code>int a = 10;
int b = 3;
System.out.println(a + b);   // Output: 13
System.out.println(a - b);   // Output: 7
System.out.println(a * b);   // Output: 30
System.out.println(a / b);   // Output: 3 (integer division)
System.out.println(a % b);   // Output: 1 (remainder)</code></pre>
    
    <h3>Logical Operators</h3>
    <p>Logical operators combine boolean expressions. The operators are AND (&&), OR (||), and NOT (!).</p>
    <pre><code>boolean x = true;
boolean y = false;
System.out.println(x && y);  // Output: false
System.out.println(x || y);  // Output: true
System.out.println(!x);      // Output: false</code></pre>
<h3>Comparison Operators</h3>
<p>Comparison operators compare numerical values and return a boolean result:  <code>&gt;</code>, <code>&lt;</code>, 
    <code>&gt;=</code>, and 
    <code>&lt;=</code>.</p>
<pre><code>int a = 10;
int b = 20;
System.out.println(a > b);    // Output: false
System.out.println(a < b);    // Output: true
System.out.println(a >= 10);  // Output: true
System.out.println(b <= 15);  // Output: false</code></pre>



</section>
    <!-- Loop Constructs Section -->
    <section id="loops">
        <h1 style="color:black">Java Loops</h1>
        <p>Below are examples of two types of <strong>for</strong> loops and a <strong>while</strong> loop:</p>
        
        <h3>Standard For Loop</h3>
        <pre><code>for (int i = 0; i < 10; i++) {
      // Print numbers 0 through 9
      System.out.println(i);
  }</code></pre>
        <p>This loop uses an index variable to iterate a fixed number of times.</p>
        
        <h3>Enhanced For Loop</h3>
        <pre><code>for (String item : items) {
      // Process each element in an array or collection
      System.out.println(item);
  }</code></pre>
        <p>This loop iterates over each element in an array or collection directly.</p>
        
        <h3>While Loop</h3>
        <pre><code>int i = 0;
  while (i < 10) {
      // Print numbers 0 through 9
      System.out.println(i);
      i++;
  }</code></pre>
        <p>The while loop continues until the specified condition is false.</p>
      </section>

 <!-- Formatting Section -->
      <section id="printf">
        <h1 style="color:black">Printf &amp; Placeholder Formatting</h1>
        <p>The <strong><code style="color:darkgreen">System.out.printf()</code></strong> method allows you to format output using placeholders instead of a concatenation operator "+". Below are some examples:</p>
        
        <h3 style="color:black">Basic Formatting</h3>
        <pre><code>System.out.printf("Name: %s, Age: %d", "Alice", 30);</code></pre>
        <div class="output">
            Name: Alice, Age: 30
          </div>
        <p>This example uses <strong><code style="color:darkgreen">%s</code></strong> for a string and <strong><code style="color:darkgreen">%d</code></strong> for an integer.</p>
       
        <h3>Floating-Point Formatting</h3>
        <pre><code>System.out.printf("Price: $%.2f", 19.99);</code></pre>
        <div class="output">
            Price: $19.99
          </div>
          <h3>Boolean Formatting</h3>
        <p>The <strong><code style="color:darkgreen">%b</code></strong> placeholder formats a boolean (true or false).</p>
      <pre><code>System.out.printf("The store is open: %b", true);</code></pre>
<div class="output">
  The store is open: true
</div>
<h3>Multiple Variables</h3>
<pre><code>int x = 10;
int y = 20;
System.out.printf("Coordinates: (%d, %d)", x, y);</code></pre>
        <div class="output">
            Coordinates: (10, 20)
          </div>
        <p>This example demonstrates using multiple placeholders within one formatted string.</p>
      </section>

      <section id="conditionals">
        <h1 style="color:black">Conditionals</h1>
        <p>Conditionals are used to execute different blocks of code based 
            on whether a condition is true or false. 
            They allow your program to make decisions and control its flow.</p>
        
        <h3>If Statement</h3>
        <pre><code>if (condition) {
    // Code to execute when condition is true
}</code></pre>
        <p>The <strong><code style="color:darkred">if</code></strong> statement 
            executes the code block only if the condition evaluates to true.</p>
        
        <h3>If-Else Statement</h3>
        <pre><code>if (condition) {
    // Code to execute when condition is true
} else {
    // Code to execute when condition is false
}</code></pre>
        <p>The <strong><code style="color:darkred">if-else</code></strong> statement allows 
            you to specify an alternative block of code if the condition is false.</p>
        
        <h3>If-Else If-Else Ladder</h3>
        <pre><code>if (condition1) {
    // Code to execute if condition1 is true
} else if (condition2) {
    // Code to execute if condition1 is false and condition2 is true
} else {
    // Code to execute if both conditions are false
}</code></pre>
        <p>This structure lets you check multiple conditions in sequence.</p>
        
        <h3>Ternary Operator</h3>
        <pre><code>int result = (condition) ? valueIfTrue : valueIfFalse;</code></pre>
        <p>The ternary operator provides a shorthand way to choose one of 
            two values based on a condition.</p>
      </section>

      <section id="return">
        <h1 style="color:black">Void, Return, and Calling Methods</h1>
        <p>
          Methods that are declared with 
          the <strong><code style="color:black">void</code></strong> or return <strong>data type</strong>. Void does not return any value. 
          In contrast, methods with a return data type must return a value of that type. 
          
        </p>
        
        <h3>Example of a Void Method</h3>
        <pre><code>public static void printMessage() {
       System.out.println("Hello from printMessage!");
      }</code></pre>
        <p>
          The <strong><code style="color:black">printMessage()</code></strong> method is declared as <strong><code style="color:black">void</code></strong> because 
          it does not return any value. 
          It simply prints a message to the console.
        </p>
        
        <h3>Example of a Method with a Return Value</h3>
        <pre><code>public static int add(int a, int b) {
       return a + b;
      }</code></pre>
        <p>
          The <strong><code style="color:black">add()</code></strong> method takes two integers as parameters and returns their sum. 
          Notice that its return type is declared as <strong><code style="color:black">int</code></strong>.
        </p>
        
        <h3>Calling Methods from <strong><code style="color:black">main()</code></strong></h3>
        <p>You call methods from the <strong><code style="color:black">main()</code></strong> by simply using the method name and 
            passing any required arguments.
        </p>
            <pre><code>public static void main(String[] args) {
      // Call the void method
      printMessage();
          
      // Call the method that returns a value and print its result
      int sum = add(5, 7);
      System.out.println("Sum: " + sum);
      }</code></pre>
        <p>
          In the example above, <strong><code style="color:black">printMessage()</code></strong> is called to print a message, and <strong><code style="color:black">add(5, 7)</code></strong> is called to compute the sum of 5 and 7. The result is stored in a variable and printed to the console.
        </p>
      </section>

      <section id="string-methods">
        <h2 style="color:black">String Methods: length, substring, and charAt</h2>
        <p>
          Java strings come with many useful methods. 
          Here are a few commonly used methods:
        </p>
        <ul>
          <li>
            <strong>length()</strong>: Returns the number of characters in the string.
          </li>
          <li>
            <strong>substring(int beginIndex, int endIndex)</strong>: Returns a new string that is a portion of 
            the original string, 
            starting at <strong><code style="color:darkred">beginIndex</code></strong> (inclusive) and 
            ending at <strong><code style="color:darkred">endIndex</code></strong> (exclusive)
          </li>
          <li>
            <strong>substring(int beginIndex)</strong>: Returns a new string that is a portion of 
            the original string, 
            starting at <strong><code style="color:darkred">beginIndex</code></strong> till the end of the string (inclusive)
          </li>
          <li>
            <strong>charAt(int index)</strong>: Returns the character at 
            the specified index in the string.
          </li>
          <li><strong>String.startsWith(String prefix)</strong>: Check whether a given string begins or ends with a particular sequence</li>
          <li> <strong>String.endsWith(String suffix)</strong>: Check whether a given string ends with a particular sequence</li>
        </ul>

        <h3>Examples:</h3>
        <pre><code>// Example of using length()
      String s = "Hello";
      System.out.println("The length of the string is: " + s.length());
      // Expected output: The length of the string is: 5
      
      // Example of using substring()
      String text = "Hello, world!";
      String sub = text.substring(7, 12);
      System.out.println("The substring is: " + sub);
      // Expected output: The substring is: world
      
      // Example of using charAt()
      char c = text.charAt(1);
      System.out.println("The character at index 1 is: " + c);
      // Expected output: The character at index 1 is: e</code></pre>
        
        <p>
          Note: String indices start at 0, and for <strong><code style="color:darkred">substring()</code></strong>, the end index is not included in the result.
        </p>
      </section>

      <section id="int-to-string">
        <h2 style="color:black">Converting Between Integers, Strings, and Characters</h2>
<p>
    In Java, you’ll often need to convert between numbers, strings, and characters. 
    Here’s how to do it safely (and avoid the common <em>"why is my number 51 instead of 3?"</em> problem).
  </p>
        <h3>1. Integer → String</h3>
  <p>Use this when you need to display numbers as text (printing, concatenation, etc.).</p>
  <pre><code>int number = 123;

// Method 1: String.valueOf()
String s1 = String.valueOf(number);

// Method 2: Integer.toString()
String s2 = Integer.toString(number);

// Method 3: Concatenation (quick and dirty)
String s3 = "" + number;</code></pre>

<h3>2. String → Integer</h3>
  <p>Use this when you’re parsing user input or text data back into a number.</p>
  <pre><code>String s = "456";
int number = Integer.parseInt(s);  // 456</code></pre>
<h3>3. Character ↔ Integer (the tricky part!)</h3>
  <p>
    Each digit character like <code style="color:black">'7'</code> has a Unicode/ASCII value (55), 
    not the numeric digit value (7). To get the actual digit:
  </p>
  <pre><code>char c = '7';

// WRONG: gives ASCII/Unicode value
int asciiValue = (int) c;   // 55

// RIGHT: subtract '0' to get the digit
int digit = c - '0';        // 7</code></pre>

  <p>
    To go the other way (digit → character):
  </p>
  <pre><code>int digit = 7;
char c = (char) ('0' + digit);  // '7'</code></pre>

<h3 style="color:darkblue">💡 Hint: Why we use '0'</h3>
<p>
  Characters like <code style="color:red">'3'</code> are stored as 
  <em>character codes</em>, not numeric values. In Unicode/ASCII:
</p>

<table border="1" cellpadding="6" style="border-collapse:collapse; text-align:center;">
  <tr><th>Character</th><th>Code Value</th><th>Digit Value</th></tr>
  <tr><td>'0'</td><td>48</td><td>0</td></tr>
  <tr><td>'1'</td><td>49</td><td>1</td></tr>
  <tr><td>'2'</td><td>50</td><td>2</td></tr>
  <tr><td>...</td><td>...</td><td>...</td></tr>
  <tr><td>'9'</td><td>57</td><td>9</td></tr>
</table>

<p>
  That’s why when you cast <b><code style="color:red">'7'</code></b> directly to an <b><code style="color:red">int</code></b>, you get <b>55</b>, 
  not <b>7</b>.  
</p>

<p>
  ✅ To fix this, always subtract <b><code style="color:red">'0'</code></b> (= code 48).  
</p>

<pre><code>char c = '7';
int digit = c - '0';   // 55 - 48 = 7
</code></pre>

<p>
  🔄 To go the other direction (digit → character):
</p>

<pre><code>int digit = 7;
char c = (char) ('0' + digit);  // 48 + 7 = 55 → '7'
</code></pre>

<p>
  Remember: <b>Subtract '0' to get a number, add '0' to get a character.</b>
</p>


  <h3>When to Use</h3>
  <ul>
    <li><b>Numbers → Strings:</b> when printing, concatenating, or storing numbers as text.</li>
    <li><b>Strings → Numbers:</b> when reading input like "123" and doing math with it.</li>
    <li><b>Characters → Digits:</b> when iterating over characters in a numeric string, e.g., summing digits in "15342".</li>
    <li><b>Digits → Characters:</b> when building up a string of numbers one digit at a time.</li>
  </ul>
</section>

      <section id="casting">
        <h1 style="color:black">Type Casting in Java</h1>
        <p>
          In Java, type casting is used to convert a variable from one data type to another. 
          This can be especially useful when you need to convert a 
          larger type to a smaller type (explicit casting) or when Java can automatically convert a value (implicit casting).
        </p>
        
        <h3>Explicit Casting (e.g., from double to int)</h3>
        <pre><code>double pi = 3.14159;
      int wholePart = (int) pi;  // wholePart becomes 3, as the decimal part is truncated</code></pre>
        <p>
          Here, the cast <code style="color:red">(int)</code> converts the double value to an integer, 
          dropping the fractional part.
        </p>
        
        <h3>Implicit Casting</h3>
        <pre><code>int a = 100;
      double b = a;  // b becomes 100.0 automatically</code></pre>
        <p>
          In this case, Java performs the conversion 
          automatically because converting an <code style="color:red">int</code> to a <code style="color:red">double</code> is safe.
        </p>
        
        <p>
          Use explicit casting when you need to convert from 
          a larger data type to a smaller one (e.g., from <code style="color:red">double</code> to <code style="color:red">int</code>). Always be cautious, as explicit casts may lead to loss of precision.
        </p>
      </section>

      <section id="arrays">
        <h1 style="color:black">Arrays and ArrayLists: Basics</h1>
        <p>
          In Java, <strong>arrays</strong> are used to store fixed-size collections of elements of the same type.
          Once an array is created, its size cannot be changed. 
          
        </p>
        
        <h3>Arrays</h3>
        <p>
          Arrays are declared with a fixed size. Here is an example of an integer array:
        </p>
        <pre><code>int[] numbers = {1, 2, 3, 4, 5};
      System.out.println("The first element is: " + numbers[0]);  // Output: 1</code></pre>
        <p>
          Note: Arrays are zero-indexed, meaning the first element is at index 0.
        </p>
        
        

        <h3>Using <code style="color:red">Arrays.toString()</code></h3>
        <p>
          When you try to print an array directly with <code style="color:red">System.out.println(array)</code>, 
          you will get a reference (such as a memory address) instead of the actual contents of the array.
        </p>
        <p>
          To display the contents of an array in a human-readable format, 
          you can use the static method <code style="color:red">Arrays.toString()</code> from the <code style="color:red">java.util.Arrays</code> class.
        </p>
        <pre><code>import java.util.Arrays;
      
    int[] numbers = {1, 2, 3, 4, 5};
    System.out.println(Arrays.toString(numbers));
    // Output: [1, 2, 3, 4, 5]</code></pre>
        <p>
          This method converts the array into a string that shows all its elements, 
          which is especially useful for debugging and verifying your results.
        </p>
      </section>


      <section id="arrayslist">
        <h2 style="color:black">ArrayLists</h2>
      <p>   <strong>ArrayLists</strong> (from the <code style="color:red">java.util</code> package)
          are resizable and provide more flexibility when you need to add or remove elements dynamically.
      <p>
        ArrayLists can grow or shrink in size. 
        To use an ArrayList, you must import it from the <code style="color:red">java.util</code> package.
      <code style="color:red">import java.util.ArrayList;</code>
      <h3>1. <code style="color:black">add(element)</code></h3>
      <p>Appends the element to the end</p>
      <pre><code>ArrayList<String> fruits = new ArrayList<>();
fruits.add("apple");
System.out.println(fruits);      // [apple]
    </code></pre>
    <h3>2. <code style="color:black">add(int index, element)</code></h3>
  <p>
    Inserts the specified element at the specified position in the list.
    Shifts the element currently at that position (if any) and any subsequent elements to the right.
  </p>
  <pre><code>ArrayList<String> fruits = new ArrayList<>();
fruits.add("apple");
fruits.add("cherry");
System.out.println(fruits);            // [apple, cherry]

fruits.add(1, "banana");               // insert "banana" at index 1
System.out.println(fruits);            // [apple, banana, cherry]
</code></pre>
<h3>3. <code style="color:black">get(int index)</code></h3>
      <p>Retrieves the element at the given index (0-based). Throws <code>IndexOutOfBoundsException</code> if invalid.</p>
      <pre><code>System.out.println(fruits.get(0));   // apple
System.out.println(fruits.get(1));   // banana
    </code></pre>
    
      <h3>4. <code style="color:black">remove(int index)</code> &amp; <code style="color:black">remove(element)</code></h3>
      <p>
        - <code style="color:black">remove(int index)</code> removes and returns the element at that position<br>
        - <code style="color:black">remove(Object o)</code> removes the first occurrence of <code style="color:black">o</code> and returns <code style="color:black">true</code> if found
      </p>
      <pre><code>String removed = fruits.remove(0);
    System.out.println(removed);       // apple
    System.out.println(fruits);        // [banana]
    
    boolean didRemove = fruits.remove("banana");
    System.out.println(didRemove);     // true
    System.out.println(fruits);        // []
    </code></pre>
    
      <h3>5. <code style="color:black">size()</code> &amp; <code style="color:black">isEmpty()</code></h3>
      <p>Check how many elements are in the list, or whether it is empty.</p>
      <pre><code>fruits.add("cherry");
    System.out.println(fruits.size());   // 1
    System.out.println(fruits.isEmpty()); // false
    
    fruits.clear();
    System.out.println(fruits.size());    // 0
    System.out.println(fruits.isEmpty()); // true
    </code></pre>
    
      <h3>6. <code style="color:black">contains(Object o)</code> &amp; <code  style="color:black">indexOf(Object o)</code></h3>
      <p>See if a list has a given element, or find its first index (-1 if not found).</p>
      <pre><code>fruits.add("apple");
    fruits.add("banana");
    System.out.println(fruits.contains("banana")); // true
    System.out.println(fruits.contains("cherry")); // false
    
    System.out.println(fruits.indexOf("apple"));   // 0
    System.out.println(fruits.indexOf("cherry"));  // -1
    </code></pre>
    
      <h3>7. <code style="color:black">clear()</code></h3>
      <p>Removes all elements; after this, the list is empty</p>
      <pre><code>fruits.clear();
    System.out.println(fruits);        // []
    System.out.println(fruits.size()); // 0
    </code></pre>

  </section>
      <section id="javadoc">
        <h2 style="color:black">Writing Javadocs</h2>
        <p>
          Javadocs are used to document your code, making it easier 
          to understand and maintain. Javadocs are placed before method or class declarations. A well-written Javadoc comment should include:
        </p>
        <p> Here is a small example of javadoc using BankAccount Class <a href="./Homework/BankAccount.java">Link</a></p>
        <ul>
          <li>A brief description of the method's purpose.</li>
          <li><code style="color:red">@param</code> tags for each parameter, explaining what they are for</li>
          <li><code style="color:red">@return</code> tag to describe the returned value (if any)</li>
          <li>Optional tags like <code style="color:red">@throws</code> if the method can throw exceptions</li>
        </ul>
        <p><strong>Example:</strong></p>
        <pre><code>
       /**
       * Computes the factorial of a given number.
       *
       * The factorial of a number (n!) is defined as:
       * n! = n * (n-1) * ... * 1.
       *
       * @param num a positive integer whose factorial is to be calculated
       * @return the factorial of num
       */</code></pre>
       
      </section>
      <section id="size">
        <h2 style="color:black">Array Length vs. ArrayList Size</h2>
        <p>
          In Java, arrays and ArrayLists both allow you to determine the number of elements they contain, but they use different syntax:
        </p>
        
        <h3>Arrays</h3>
        <p>
          Arrays have a built-in property called <code style="color:red">length</code> that returns the number of elements in the array. 
          Note that <code style="color:red">length</code> is a field, so you do not use parentheses.
        </p>
        <pre><code>int[] arr = {1, 2, 3, 4, 5};
      System.out.println("Array length: " + arr.length);  // Output: 5</code></pre>
        
        <h3>ArrayLists</h3>
        <p>
          ArrayLists, which are part of the <code style="color:red">java.util</code> package, use a method called <code style="color:red">size()</code> to return the number of elements. Unlike arrays, you must call it with parentheses.
        </p>
        <pre><code>import java.util.ArrayList;
      
      ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
      list.add("apple");
      list.add("banana");
      System.out.println("ArrayList size: " + list.size());  // Output: 2</code></pre>
        
        <p>
          Remember:
          <ul>
            <li><code style="color:red">array.length</code> — no parentheses because it's a property.</li>
            <li><code style="color:red">arrayList.size()</code> — parentheses are required because it's a method.</li>
          </ul>
        </p>
        <h3>ArrayList Methods: contains() and isEmpty() and addAll()</h3>
        <p>
          <code style="color:red">ArrayList</code> class provides several useful methods for checking its state:
        </p>
        <ul>
          <li>
            <strong>contains():</strong> Returns <code style="color:red">true</code> if the ArrayList contains the specified element; otherwise, it returns <code style="color:red">false</code>.
          </li>
          <li>
            <strong>isEmpty():</strong> Returns <code style="color:red">true</code> if the ArrayList has no elements, and <code style="color:red">false</code> if it contains one or more elements.
          </li>
          <strong>addAll():</strong> Adds all of the elements in the specified collection to the ArrayList.
            This method is useful for merging lists or adding a batch of elements at once.
          </li>
        </ul>
        
        <pre><code>ArrayList&lt;String&gt; fruits = new ArrayList&lt;String&gt;();
// Check if the list is empty
if (fruits.isEmpty()) {
    System.out.println("The list is empty.");
}
              
// Add some elements to the list
fruits.add("apple");
fruits.add("banana");
              
// Check if a specific element is in the list using contains()
if (fruits.contains("banana")) {
    System.out.println("The list contains banana.");
} else {
    System.out.println("The list does not contain banana.");
}
// Create another list of fruits
ArrayList&lt;String&gt; moreFruits = new ArrayList&lt;String&gt;();

// Use addAll() to add all elements from moreFruits to fruits
fruits.addAll(moreFruits);
</code></pre>

      </section>
             
      <section id="math">
        <h2 style="color:black">The Math Library in Java</h2>
        <p>
          Java's <code style="color:red">Math</code> class provides a 
          collection of static methods for performing basic numeric operations,
          such as exponentiation, square roots, absolute values, and 
          trigonometric calculations. Since all methods are static,
          you can call them directly using <code style="color:red">Math.methodName()</code> without 
          creating an instance of the class.
        </p>
        
        <h3>Common Methods:</h3>
        <ul>
          <li><code style="color:red">Math.abs(x)</code> — Returns the absolute value of <code>x</code>.</li>
          <li><code style="color:red">Math.pow(a, b)</code> — Returns <code>a</code> raised to the power of <code style="color:red">b</code>.</li>
          <li><code style="color:red">Math.sqrt(x)</code> — Returns the square root of <code style="color:red">x</code>.</li>
          <li><code style="color:red">Math.max(a, b)</code> — Returns the maximum of <code style="color:red">a</code> and <code style="color:red">b</code>.</li>
          <li><code style="color:red">Math.min(a, b)</code> — Returns the minimum of <code style="color:red">a</code> and <code style="color:red">b</code>.</li>
          <li><code style="color:red">Math.floor(x)</code> — Returns the largest integer less than or equal to <code style="color:red">x</code>.</li>
          <li><code style="color:red">Math.ceil(x)</code> — Returns the smallest integer greater than or equal to <code style="color:red">x</code>.</li>
          <li><code style="color:red">Math.round(x)</code> — Rounds <code style="color:red">x</code> to the nearest integer.</li>
        </ul>
        
        <h3>Examples:</h3>
        <pre><code>// Example of Math.abs()
      int a = -5;
      System.out.println("Absolute value: " + Math.abs(a));  // Output: 5
      
      // Example of Math.pow()
      double power = Math.pow(2, 3);
      System.out.println("2 raised to 3: " + power);  // Output: 8.0
      
      // Example of Math.sqrt()
      double root = Math.sqrt(16);
      System.out.println("Square root of 16: " + root);  // Output: 4.0
      
      // Example of Math.max() and Math.min()
      System.out.println("Max of 10 and 20: " + Math.max(10, 20));  // Output: 20
      System.out.println("Min of 10 and 20: " + Math.min(10, 20));  // Output: 10</code></pre>
        
        
      </section>

      <section id="scanner">
        <h2 style="color:black">Using the Scanner Class in Java</h2>
        <p>
          The <code style="color:red">Scanner</code> class is used to read input from various sources (such as keyboard input, files, or strings). 
          To use it, you first need to import it:
        </p>
        <pre><code>import java.util.Scanner;</code></pre>
        <p>
          Here are some common methods of the <code>Scanner</code> class:
        </p>
        <ul>
          <li><code style="color:red">nextLine()</code>: Reads an entire line of input as a <code style="color:red">String</code></li>
          <li><code style="color:red">next()</code>: Reads the next token (=word) as a <code style="color:red">String</code> (no spaces)</li>
          <li><code style="color:red">nextInt()</code>: Reads the next token as an <code style="color:red">int</code></li>
          <li><code style="color:red">nextDouble()</code>: Reads the next token as a <code style="color:red">double</code>.</li>
        </ul>
        <p>
          <strong>Example:</strong>
        </p>
        <pre><code>Scanner scanner = new Scanner(System.in);
              
// Prompt and read the user's full name
System.out.println("Enter your name:");
String name = scanner.next();

// Output the values
System.out.println("Name: " + name);
// Close the scanner to free resources
scanner.close();
</code></pre>
      </section>
      <section id="heterogeneous">
        <h2 style="color:black" >Heterogeneous ArrayLists</h2>
        <p>
          By default, ArrayList allows you to create collections that store elements of a specific type (Integer or String etc).
          If you need a heterogeneous collection (storing elements of different types), you can declare your ArrayList to hold objects of type <code style="color:red">Object</Object></code>.
        </p>
        <p>
          Example of an Array with String, Integer, Double, Boolean:
        </p>
        <pre><code>ArrayList&lt;Object&gt; mixedList = new ArrayList&lt;&gt;();

mixedList.add("Hello");
mixedList.add(10);
mixedList.add(45.67);
mixedList.add(true);

System.out.println(mixedList): // Output: [Hello, 10, 45.67, true]</code></pre>
      </section>

      <section id="data-type">
        <h2 style="color:black">Determining Data Types for Primitives and Objects</h2>
        <p>
          In Java, there are two main categories of data types: <strong>primitive types</strong> and <strong>reference types (objects)</strong>.
        </p>
        <p>
            <ul>
              <li>Primitive types do not have methods and their type is known at compile time</li>
              <li>To inspect a primitive’s type at runtime, you can rely on autoboxing to wrap it in its corresponding wrapper class</li>
              <li>For objects, use <code style="color:red">getClass().getSimpleName()</code> to get the class name</li>
            </ul>
          </p>
        
        <h3>Primitive Data Types</h3>
        <p>
          Java’s primitive types include <code style="color:red">byte</code>, <code style="color:red">short</code>, <code style="color:red">int</code>, <code style="color:red">long</code>, <code style="color:red">float</code>, <code style="color:red">double</code>, <code style="color:red">char</code>, and <code style="color:red">boolean</code>. 
          Primitives are not objects and do not have methods, so you cannot call methods like <code style="color:red">getClass()</code> on them.
        </p>
        <p>
          To determine the type of a primitive at runtime, you typically rely on compile-time type information. 
          Alternatively, if you need to inspect a primitive’s type at runtime, you can use <strong>autoboxing</strong> to wrap it in its corresponding wrapper class.
        </p>
        <pre><code>int num = 5;

System.out.println(((Object)num).getClass().getSimpleName()); // Prints "Integer"
        </code></pre>
        <p>
          <strong>Note:</strong> When you cast a primitive to <code style="color:red">Object</code>, Java automatically converts (autoboxes) it to its corresponding wrapper type (e.g., <code style="color:red">int</code> becomes <code style="color:red">Integer</code>).
        </p>
        
        <h3>Reference Data Types (Objects)</h3>
        <p>
          For objects, you can use the <code style="color:red">getClass()</code> method to determine the runtime type.
        </p>
        <pre><code>String str = "Hello";

System.out.println(str.getClass().getSimpleName());  // Output: "String"
        </code></pre>
        
        
      </section>
      <section id="instanceof">
        <h2 style="color:black">Using the <code style="color:red">instanceof</code> Operator</h2>
        <p>
          The <code style="color:red">instanceof</code> operator in Java is used to check whether an object is an instance of a specific class.
          This is useful for ensuring that you can safely cast an object or perform type-specific operations.
        </p>
        
        <h3>Syntax</h3>
        <pre><code>if (object instanceof ClassName) {
    // Do something
}</code></pre>
        <p>
          The expression returns <code style="color:red">true</code> 
          or <code style="color:red">false</code>.
        </p>
        
        <h3>Example</h3>
        <pre><code>Object value = "Hello, world!";

if (value instanceof String) {
    System.out.println("The object is a String.");
} else {
    System.out.println("The object is not a String.");
}
// Output: The object is a String.</code></pre>
      </section>
      <section id="hashmap">
        <h2 style="color:black">HashMaps</h2>
        <p>
          A <strong>HashMap</strong> is a collection that stores key-value pairs. 
          It allows you to efficiently retrieve, update, and remove values based on a unique key.
        </p>
        <p>Keys are unique. Each key maps to one value.
        </p>
        <p><code style="color:red">import java.util.HashMap;</code></p>
        <h3>Common Methods:</h3>
        <ul>
          <li><code style="color:red">put(key, value)</code>: Associates the specified value with the specified key</li>
          <li><code style="color:red">get(key)</code>: Returns the value to which the specified key is mapped, or <code style="color:red">null</code> if this map contains no mapping for the key</li>
          <li><code style="color:red">containsKey(key)</code>: Returns <code style="color:red">true</code> if the map contains a mapping for the specified key</li>
          <li><code style="color:red">remove(key)</code>: Removes the mapping for a key from this map if it is present</li>
          <li><code style="color:red">keySet()</code>: Returns a Set view of the keys contained in the map</li>
        </ul>
        
        <h3>Example Usage:</h3>
        <pre><code>HashMap&lt;String, Integer&gt; ages = new HashMap&lt;&gt;();
              
ages.put("Alice", 30);
ages.put("Bob", 25);
              ages.put("Charlie", 35);
              
// Retrieve a value using get()
System.out.println("Alice's age: " + ages.get("Alice"));
              
// Check if a key exists
if (ages.containsKey("Bob")) {
    System.out.println("Bob is in the map.");
}
              
// Iterate over keys and print values
for (String name : ages.keySet()) {
    System.out.println(name + " is " + ages.get(name) + " years old.");
}
              
// Remove an entry
ages.remove("Charlie");
System.out.println("Map after removing Charlie: " + ages);</code></pre>

      </section>
      <section id="fields">
        <h2 style="color:black">Understanding Fields in Java</h2>
        <p>
          In Java, <strong>fields</strong> are variables declared within a class that store data associated with objects. There are two types:
        </p>
        <ul>
          <li>
            <strong>Instance Fields:</strong> Each object has its own copy. They store information specific to that instance.
          </li>
          <li>
            <strong>Static Fields:</strong> Belong to the class rather than any one object, so they are shared among all instances.
          </li>
        </ul>
        <p>
          Below is an example of a <code style="color:red">Car</code> class that demonstrates both instance and static fields:
        </p>
        <pre><code>public class Car {
          // Instance fields: each Car has its own make, model, year, and mileage.
          private String make;
          private String model;
          private int year;
          private double mileage;
          
          // Static field: counts how many Car objects have been created.
          private static int carCount = 0;
          
          /**
           * Constructs a new Car with the specified make, model, and year.
           * Mileage is set to 0 by default.
           *
           * @param make  the manufacturer of the car
           * @param model the model of the car
           * @param year  the year the car was made
           */
          public Car(String make, String model, int year) {
              this.make = make;
              this.model = model;
              this.year = year;
              this.mileage = 0;
              carCount++; // Increase count for every new car created
          }
          
          /**
           * Simulates driving the car by adding miles to the mileage.
           *
           * @param miles the number of miles to add
           */
          public void drive(double miles) {
              mileage += miles;
          }
          
          /**
           * Returns a description of the car, including its make, model, year, and mileage.
           *
           * @return a String describing the car
           */
          public String getDescription() {
              return year + " " + make + " " + model + " with " + mileage + " miles";
          }
          
          /**
           * Returns the total number of Car objects created.
           *
           * @return the number of cars created
           */
          public static int getCarCount() {
              return carCount;
          }
          
          // You can add other methods to update or access the car's information as needed.
      }</code></pre>
        <p>
          In this example:
        </p>
        <ul>
          <li>The instance fields <code style="color:red">make</code>, <code style="color:red">model</code>, <code style="color:red">year</code>, and <code style="color:red">mileage</code> store data for each Car object.</li>
          <li>The static field <code style="color:red">carCount</code> keeps track of the total number of Car objects created, and is shared among all instances.</li>
          <li>Methods such as <code style="color:red">drive</code> and <code style="color:red">getDescription</code> work with the instance fields, while <code style="color:red">getCarCount</code> works with the static field.</li>
        </ul>

      </section>
      <section id="static">
        <h2 style="color:black">Understanding Static</h2>
        <p>
          In Java, the <code style="color:red">static</code> keyword is used to indicate that a field 
          or method belongs to the class itself rather than to any individual instance (object) of that class.
          This means that:
        </p>
        <ul>
          <li>Static fields are shared among all instances of a class</li>
          <li>Static methods can be called without creating an object of the class</li>
        </ul>
        
        <h3>Static Fields</h3>
        <p>
          Static fields are useful for storing data that should be common to all instances:
        </p>
        <pre><code>public class Example {
          public static int counter = 0;  // This field is shared by all instances of Example.
          
          public Example() {
              counter++; // Each time an Example object is created, counter increases.
          }
          
          public static void main(String[] args) {
              new Example();
              new Example();
              System.out.println("Counter: " + Example.counter); // Output: Counter: 2
          }
      }
        </code></pre>
        <p>
          In this example, <code style="color:red">counter</code> is a static field. 
          It is updated every time a new object is created, and its value is shared across all instances.
        </p>
        
        <h3>Static Methods</h3>
        <p>
          Static methods belong to the class, 
          so you do not need to create an instance to call them. 
          They are often used for utility or helper functions.
        </p>
        <pre><code>public class MathUtil {
          public static int add(int a, int b) {
              return a + b;
          }
          
          public static void main(String[] args) {
              // Calling the static method without creating an instance of MathUtil.
              int result = MathUtil.add(5, 3);
              System.out.println("5 + 3 = " + result); // Output: 5 + 3 = 8
          }
      }
        </code></pre>
        <p>
          Here, the <code style="color:red">add</code> method is declared as static, 
          so it is called using the class name (<code style="color:red">MathUtil.add(5, 3)</code>) rather than through an object.
        </p>
        
        <h3>When to Use Static</h3>
        <ul>
          <li>For utility or helper methods that do not depend on the state of an object</li>
          <li>For fields that are constant or should be shared across all instances</li>
          <li>For tracking class-wide information, such as the total number of instances created</li>
        </ul>
        
        <p>
          Remember: Static members are accessed via the class name and exist independently of any object instances. 
          
        </p>
      </section>

      <section id="this-keyword">
        <h2 style="color:black">Understanding the <code style="color:red">this</code> Keyword</h2>
        <p>
          The <code style="color:red">this</code> keyword is a reference to the current object—the instance on which a method or constructor is being called.
          It is especially useful when you have parameter names that are the same as instance field names.
        </p>
        <p>
          <strong>When to Use <code>this</code>:</strong>
        </p>
        <ul>
          <li>
            To differentiate between instance variables (fields) and parameters in a constructor or method.
          </li>
          <li>
            To call another constructor in the same class (using <code style="color:red">this()</code>).
          </li>
          <li>
            To pass the current object as an argument to another method.
          </li>
        </ul>
        

        <h3>Example with Fields</h3>
        <pre><code>public class Person {
          private String name;
          
          public Person(String name) {
              // Use 'this' to refer to the instance variable
              this.name = name;
          }
          
          public void printName() {
              // 'this.name' is optional here since there's no conflict, but it can improve readability.
              System.out.println("Name: " + this.name);
          }
          
          public static void main(String[] args) {
              Person person = new Person("Alice");
              person.printName(); // Output: Name: Alice
          }
      }
      </code></pre>
      <h3>Using <code style="color:red">this()</code> in Constructors</h3>
      <p>
        You can use <code style="color:red">this()</code> inside a constructor to call another constructor in the same class.
        This technique helps reduce code duplication when you have multiple constructors that share common initialization tasks.
      </p>
      <h3>Example with Constructor</h3>
      <pre><code>public class Book {
        private String title;
        private String author;
        private double price;
        
        // Primary constructor that initializes all fields.
        public Book(String title, String author, double price) {
            this.title = title;
            this.author = author;
            this.price = price;
        }
        
        // Overloaded constructor that provides a default price.
        public Book(String title, String author) {
            // Calls the primary constructor with a default price of 0.0.
            this(title, author, 0.0);
        }
        
        public void printDetails() {
            System.out.println("Title: " + title + ", Author: " + author + ", Price: $" + price);
        }
        
        public static void main(String[] args) {
            // Create a Book instance using the constructor with all parameters.
            Book book1 = new Book("1984", "George Orwell", 9.99);
            // Create a Book instance using the overloaded constructor with a default price.
            Book book2 = new Book("Animal Farm", "George Orwell");
            
            book1.printDetails(); // Output: Title: 1984, Author: George Orwell, Price: $9.99
            book2.printDetails(); // Output: Title: Animal Farm, Author: George Orwell, Price: $0.0
        }
    }
    </code></pre>
      <p>
        In this example, the second constructor uses <code style="color:red">this(title, author, 0.0);</code> to call the primary constructor,
        ensuring that all initialization is handled in one place.
      </p>

      </section>

      <section id="override">
        <h2 style="color:black">Understanding Overridde Method - toString()</h2>
        <p>
      <p>
        By default, printing an object in Java calls the <code style="color:red">toString()</code> method from the <code style="color:red">Object</code> class,
        which typically returns a string that includes the object's class name and hash code.</p>
        <p>We can customize this method by overriding the <code style="color:red">toString()</code>.</p>
      </p>
      
      <h3>BankAccount Example</h2>
      <p>
        In this example, we override the <code style="color:red">toString()</code> method in the <code style="color:red">BankAccount</code> class to print the
        account's name and balance.
      </p>

      <pre><code>
    public class BankAccount {
        private String name;
        private double balance;
        
        public BankAccount() {
            this.name = "Unknown user";
            this.balance = 0;
        }
        
        public BankAccount(String name, double balance) {
            this.name = name;
            this.balance = balance;
        }
        
        public String getName() {
            return name;
        }
        
        public double getBalance() {
            return balance;
        }
        
        public void deposit(double amount) {
            balance += amount;
        }
        
        // Overriding the toString() method example to print name and balance
        @Override
        public String toString() {
            return "BankAccount{name='" + name + "', balance=" + balance + "}";
        }
        
        public static void main(String[] args) {
            BankAccount account1 = new BankAccount("Yoda", 500);
            BankAccount account2 = new BankAccount("C3PO", 1000);
            
            System.out.println(account1);
            System.out.println(account2);
        }
    }
      </code></pre>
      
      <h2>Explanation</h2>
      <ul>
        <li>
          <strong>Default Behavior:</strong> Without overriding <code style="color:red">toString()</code>, printing a BankAccount object would show something like <code>BankAccount@15db9742</code>.
        </li>
        <li>
          <strong>Overridden Method:</strong> We override <code style="color:red">toString()</code> to return a string that clearly shows the account's
          <code style="color:red">name</code> and <code style="color:red">balance</code>.
        </li>
        <li>
          <strong>Usage:</strong> When you print an instance of <code style="color:red">BankAccount</code>, Java calls your overridden method,
          displaying the custom string representation.
        </li>
      </ul>
    </section>
<section id="recursion">
    <h2 style="color:black">Key Concepts in Recursion</h2>
    <ul>
      <li>
        <strong>Base Case:</strong> The condition that stops the recursive calls. Without a base case, recursion would continue indefinitely.
      </li>
      <li>
        <strong>Recursive Case:</strong> The part of the method where the function calls itself with a smaller or simpler input.
      </li>
      <li>
        <strong>Helper Methods:</strong> Sometimes used to hide additional parameters that manage state in recursion
      </li>
    </ul>
  
    <h3>Example 1: Void Recursion Method</h3>
    <p>
      This example demonstrates a recursive method that prints a countdown from <code style="color:black">n</code> to 1 and then prints "Lift off!".
    </p>
    <pre><code>public void printCountdown(int n) {
      if (n <= 0) {
          System.out.println("Lift off!");
      } else {
          System.out.println(n);
          printCountdown(n - 1); // Recursive call
      }
  }</code></pre>
  
    <h3>Example 2: Recursion with Return</h3>
    <p>
      In this example, the recursive method calculates the factorial of a number. 
      The factorial of a number <code style="color:red">n</code> (denoted as n!) is the product of all positive integers less than or equal to n.
    </p>
    <pre><code>public int factorial(int n) {
      if (n <= 1) {
          return 1; // Base case
      } else {
          return n * factorial(n - 1); // Recursive call with return value
      }
  }</code></pre>
  
    <h3>Example 3: Recursion with a Helper Function</h3>
    <p>
      Sometimes a helper function is used to manage 
      extra parameters that keep track of state during recursion. 
      In this example, we compute the sum of all numbers from 1 up to n using a helper method.
    </p>
    <pre><code>public int sumUpTo(int n) {
      return sumHelper(n, 0);
  }
  
  private int sumHelper(int n, int accumulator) {
      if (n == 0) {
          return accumulator; // Base case: no more numbers to add
      } else {
          return sumHelper(n - 1, accumulator + n); // Recursive call: add current number to accumulator
      }
  }</code></pre>
  

  </section>

      <section id="uml-rules">
        <h2 style="color:black">Understanding UML Class Diagrams</h2>
        <p>
          UML (Unified Modeling Language) is a standardized way to visually represent the structure and design of a system. One of the most common UML diagrams is the class diagram, which shows classes, their attributes (fields), and their operations (methods).
        </p>
        <p>UML Handout: <a href="./resources_files/UML_Cheatsheet.pdf">Download</a></p>
        <p>OOP Handout: <a href="./resources_files/Basic_OO_Principles_for_CSSE220.pdf">Download</a></p>
        
        <h3>1. Class Name</h3>
        <p>
          The class name is placed at the top of the diagram and is usually centered and in bold. In our example, the class is named <code>Car</code>.
        </p>
        <pre><code>Car</code></pre>
        
        <h3>2. Attributes (Fields)</h3>
        <p>
          The middle section of the diagram lists the attributes (or fields) of the class. Each attribute is preceded by an access modifier:
        </p>
        <ul>
          <li><code style="color:red">-</code> : private</li>
          <li><code style="color:red">+</code> : public</li>
          <li><code style="color:red">#</code> : protected</li>
        </ul>
        <p>
          For our Car class, you might have the following attributes:
        </p>
        <pre><code>- make: String
      - model: String
      - year: int
      - mileage: double</code></pre>
        
        <h3>3. Operations (Methods)</h3>
        <p>
          The bottom section of the diagram shows 
          the operations (methods) of the class, also with access modifiers.
        </p>
        <pre><code>+ Car(make: String, model: String, year: int)
      + getDescription(): String
      + drive(miles: double): void</code></pre>
        <p>
          In this example:
          <ul>
            <li>The constructor <code style="color:red">Car(make, model, year)</code> is public and 
                initializes the object</li>
            <li><code style="color:red">getDescription()</code> returns a description of the car</li>
            <li><code style="color:red">drive(miles)</code> simulates driving by updating the mileage</li>
          </ul>
        </p>
        
        <h3>4. Diagram Structure</h3>
        <p>
          A typical UML class diagram is divided into three compartments:
        </p>
        <ol>
          <li><strong>Top Section:</strong> Contains the class name</li>
          <li><strong>Middle Section:</strong> Lists the attributes (fields) with their types and access modifiers</li>
          <li><strong>Bottom Section:</strong> Lists the operations (methods) with parameters, return types, and access modifiers</li>
        </ol>
        
        <h3>5. Example UML Diagram for the Car Class</h3>
        <p>
          Here’s how a UML diagram for the Car class might look:
        </p>
        <pre><code>---------------------------
      |          Car            |
      ---------------------------
      | - make: String          |
      | - model: String         |
      | - year: int             |
      | - mileage: double       |
      ---------------------------
      | + Car(make, model, year)|
      | + getDescription(): String |
      | + drive(miles: double): void |
      ---------------------------
      </code></pre>
        <p>
          This diagram tells us that:
          <ul>
            <li>The class is called <code style="color:red">Car</code></li>
            <li>It has four private instance fields: <code style="color:red">make</code>, <code style="color:red">model</code>, <code style="color:red">year</code>, and <code style="color:red">mileage</code>.</li>
            <li>It includes a public constructor and two public methods to interact with the car's state</li>
          </ul>
        </p>
        
        <h3>6. Additional UML Notations</h3>
        <p>
          For more complex systems, UML diagrams can also show relationships 
          between classes (inheritance, associations, dependencies).
        </p>
      </section>

      <section id="interface">
        <h2 style="color:black">Understanding Interfaces in Java</h2>
        <p>
          In Java, an <strong>interface</strong> is a reference type that defines 
          a set of methods without implementing them.
          It specifies what a class must do, but not how it does it.
        </p>
        <p>Key points about interfaces:</p>
        <ul>
          <li>Interfaces provide a way to achieve abstraction and allow for multiple inheritance of type</li>
          <li>A class can implement multiple interfaces, which promotes flexible and modular design</li>
        </ul>
        
        <h3>Example: Defining and Using an Interface</h3>
        <pre><code>// Define an interface called Drawable
      public interface Drawable {
          void draw();
      }
      
      // Implement the Drawable interface in a class called Circle
      public class Circle implements Drawable {
          @Override
          public void draw() {
              System.out.println("Drawing a circle");
          }
      }
      
      // Using the interface in a main method
      public class InterfaceExample {
          public static void main(String[] args) {
              // A Circle object is referenced as a Drawable
              Drawable shape = new Circle();
              shape.draw(); // Output: Drawing a circle
          }
      }</code></pre>
        
        <p>
          In this example:
        </p>
        <ul>
          <li>
            The <code style="color:red">Drawable</code> interface declares a method <code style="color:red">draw()</code> without providing an implementation.
          </li>
          <li>
            The <code style="color:red">Circle</code> class implements the <code style="color:red">Drawable</code> interface and provides its own implementation of <code style="color:red">draw()</code>.
          </li>
          <li>
            In the main method, a <code style="color:red">Circle</code> object is created and assigned to a variable of type <code style="color:red">Drawable</code>, demonstrating polymorphism.
          </li>
        </ul>
      </section>

      <section id="initialization">
        <h2 style="color:black">Field vs Constructor Initialization</h2>
        <p>In Java, instance variables (fields) can be initialized either directly where they are declared or inside the constructor. 
            Each approach has its nuances and benefits:</p>
        
        <h3>Field Initialization</h3>
        <ul>
          <li><strong>Simplicity and Readability:</strong> Initializing fields at the point of declaration 
            makes your code concise and clear</li>
          <li><strong>Automatic Initialization:</strong> The field is set up regardless of which constructor is called, 
            ensuring a common default value</li>
          <li><strong>Avoiding Repetition:</strong> Multiple constructors do not need to repeat the same initialization code</li>
        </ul>
        <pre><code>
    public class Example {
        private int count = 10;  // Field initialization
    
        public Example() {
            // count is already 10
        }
    
        public Example(int newCount) {
            // count can be overwritten if needed
            count = newCount;
        }
    }
        </code></pre>
        
        <h3>Constructor Initialization</h3>
        <ul>
          <li><strong>Flexibility:</strong> Fields can be set based on constructor parameters or more complex logic</li>
          <li><strong>Multiple Initialization Paths:</strong> Different constructors can initialize fields in different ways</li>
          <li><strong>Dependency Injection:</strong> Field values can be provided during object creation</li>
        </ul>
        <pre><code>
    public class Example {
        private int count;
    
        public Example() {
            // Default value computed or defined here
            this.count = 10;
        }
    
        public Example(int newCount) {
            // Use the value provided during object creation
            this.count = newCount;
        }
    }
        </code></pre>
        
        <h3>Choosing Between Them</h3>
        <p><strong>Field Initialization:</strong> Use when the default value is constant 
            or you want to avoid duplication across multiple constructors</p>
        <p><strong>Constructor Initialization:</strong> Use when the initialization value depends on parameters or 
            requires additional logic</p>
      </section>


      <section id="illegalcast">
        <h2 style="color:black">Introduction: Determining Illegal Casts</h2>
        <p>
          In Java, whether a cast is legal depends on the <em>inheritance hierarchy</em> (or interface relationships) between the types involved.  
          There are two main checks:
        </p>
        <ol>
          <li>
            <strong>Compile‐time check:</strong><br>
            The <em>static type</em> (the variable’s declared type) must be related to the <em>target type</em> by subclassing or interface implementation.  
            - If the compiler sees that <code style="color:darkred">TypeA</code> and <code style="color:darkred">TypeB</code> share no inheritance path, it rejects 
              <code style="color:darkred">(TypeB) aVariable</code> as an “inconvertible types” compile‐time error.
          </li>
          <li>
            <strong>Run‐time check (downcasts only):</strong><br>
            Even if the compile‐time check passes, a <em>downcast</em> (superclass → subclass) must be verified at runtime.  
            The JVM ensures the actual object is an instance of the <em>target type</em> (or its subclass).  
            If not, you get a <code style="color:darkred">ClassCastException</code> at runtime.
          </li>
        </ol>
      
        <h3>Quick Rules</h3>
        <ul>
          <li>
            <strong>Upcast (subclass → superclass or interface):</strong>  
            Always safe, and often implicit—no explicit <code style="color:darkred">(Type)</code> needed.
          </li>
          <li>
            <strong>Downcast (superclass → subclass):</strong>  
            Requires an explicit <code style="color:darkred">(TargetType)</code>.  
            If the object is not really that subtype, you’ll see a <code style="color:darkred">ClassCastException</code> at runtime.
          </li>
          <li>
            <strong>Unrelated types:</strong>  
            Compiler error—Java will not allow you to cast between classes or interfaces that don’t share any “is-a” relationship.
          </li>
        </ul>
      
        <h3>Inheritance Hierarchy Example</h3>
        <pre><code>
      // Suppose we have:
      interface Animal { … }
      class Dog implements Animal { … }
      class Poodle extends Dog { … }
      class Cat implements Animal { … }
      
      // Legal upcast (implicit):
      Animal a1 = new Dog();
      Animal a2 = new Poodle();
      
      // Legal downcast (explicit) – allowed at compile time, but must pass runtime check:
      Dog d1 = (Dog) a1;        // OK if a1 actually refers to a Dog
      Poodle p1 = (Poodle) a2;  // OK if a2 actually refers to a Poodle
      
      // Illegal downcast – compiles but fails at runtime if object mismatches:
      Poodle p2 = (Poodle) a1; // ClassCastException if a1 is a Dog, not a Poodle
      
      // Compile‐time error – unrelated classes:
      Poodle p3 = (Poodle) new Cat(); // compile‐time error: Cat cannot be converted to Poodle
        </code></pre>
      </section>

      <section id="switch-cases">
        <h2 style="color:black">Using Switch Cases in Java</h2>
        <p>
          The <code style="color:red">switch</code> statement in Java allows you to 
          execute different blocks of code based on the value of a single variable. 
          It is an alternative to multiple <code style="color:red">if-else</code> statements when testing the same 
          variable against several constant values.
        </p>
        
        <h3>Syntax</h3>
        <pre><code>switch (variable) {
          case value1:
              // Code block for value1
              break;
          case value2:
              // Code block for value2
              break;
          // Additional cases...
          default:
              // Code block if no case matches
      }</code></pre>
        
        <p>
          <strong>Key Points:</strong>
          <ul>
            <li>
              Each <code style="color:red">case</code> represents a potential value of the variable
            </li>
            <li>
              The <code style="color:red">break</code> statement stops 
              further execution within the switch after a case is matched
            </li>
            <li>
              The <code style="color:red">default</code> case is executed if none of the cases match
            </li>
            <li>
              Switch works with primitive types like <code style="color:red">int</code>, <code style="color:red">char</code>, and also with <code style="color:red">String</code>.
            </li>
          </ul>
        </p>

</section>

<section id="junit">
  <h2 style="color:black">JUnit Testing in Java</h2>

  <h3>1. Create a new JUnit</h3>
  <p>Select New JunitTest -> JUnit 4 -> check @Before setUp()</p>
<p>Add fields (see Example with LinkedList)</p>
<p>In setUp() instantiate new Class, add value for testing (see LinkedLlist example Lab 18)</p>
<pre><code>
  class CalculatorTest {
      private Calculator calc;
  
      @BeforeEach
      void setUp() {
          calc = new Calculator();  // class under test
      }

    </code></pre>

  <h3 style="color:black">3. Some Common Assertions</h3>
  <ul>
    <li><code style="color:black">assertEquals(expected, actual)</code>: compare primitives or objects</li>
    <li><code style="color:black">assertNotEquals(unexpected, actual)</code></li>
    <li><code style="color:black">assertTrue(condition)</code>, <code style="color:black">assertFalse(condition)</code></li>
  </ul>

  <h3 style="color:black">4. Examples</h3>
  <p><strong>Testing a Division Method (with exception):</strong></p>
  <pre><code>@Test
void testAdd() {
  assertEquals(4, calc.add(1, 3))
}</code></pre>

  <h3 style="color:black">5. Running Tests</h3>
  <p>In Eclipse: Right-click the test file or project → Run As → JUnit Test<br>
  </p>
</section>

<section id="files">
  <h2 style="color:black">File I/O in Java: Writing &amp; Reading</h2>

  <h3>1. Writing to a Text File</h3>
  <p>
    Use a <code style="color:black">PrintWriter</code> wrapped around a <code style="color:black">FileWriter</code>
  </p>
  <p>Consider creating a class with static helper methods, like FileIOUtils</p>
  <pre><code>public static void writeLine(String filename, String line) {
    // 'true' = append mode; set to 'false' to overwrite
    try (PrintWriter out = new PrintWriter(
           new FileWriter(filename, true)   // FileWriter in append mode
         )) {
      out.println(line);
    } catch (IOException e) {
      System.err.println("Write error: " + e.getMessage());
    }
  }
}</code></pre>

  <h3>2. Reading from a Text File</h3>
  <p>
    Use a <code style="color:black">BufferedReader</code> or <code style="color:black">Scanner</code>
  </p>
  <pre><code>
  public static List&lt;String&gt; readAllLines(String filename) {
    List&lt;String&gt; lines = new ArrayList&lt;&gt;>();
    try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {
      String line;
      while ((line = reader.readLine()) != null) {
        if (!line.isBlank()) {
          lines.add(line.trim());
        }
      }
    } catch (IOException e) {
      System.err.println("Read error: " + e.getMessage());
    }
    return lines;
  }
}</code></pre>

  <h3>3. Usage Example</h3>
  <pre><code>String file = "scores.txt";
    // Write a score
    FileIOUtils.writeLine(file, "Alice, 42");
    // Read back all scores
    List&lt;String&gt; scores = FileIOUtils.readAllLines(file);
  }
}</code></pre>

  <h3>4. Key Points</h3>
  <ul>
    <li>Use <code style="color:black">FileWriter(filename, true)</code> to append vs. overwrite</li>
    <li>Handle <code style="color:black">IOException</code></li>
    <li>Trim and filter blank lines when reading for cleaner data</li>
  </ul>
</section>

<section id="swing">
    <h2 style="color:black">Swing Components</h1>
    <p>
        In Java Swing, you can build GUI applications by combining components like <code style="color:red">JPanel</code> and <code style="color:red">JComponent</code> 
        within a <code style="color:red">JFrame</code>. You also use layout managers to control the positioning of these components.
    </p>
    
    <h3>JFrame and Layout Managers</h3>
    <p>
        A JFrame is the top-level container for your Swing application. 
        You add your panels or custom components 
        to the JFrame's content pane and 
        manage their layout using layout managers like <code style="color:red">FlowLayout</code>, <code style="color:red">BorderLayout</code>, 
        <code style="color:red">GridLayout</code>, or <code style="color:red">BoxLayout</code>.
    </p>
    <pre><code>
// Create a JFrame and set its layout (BorderLayout is the default for JFrame's content pane)
JFrame frame = new JFrame("My Application");
frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
frame.setLayout(new BorderLayout());

// Add components (JPanel or custom JComponent) to the frame
frame.add(new MyPanel(), BorderLayout.CENTER);

frame.pack();
frame.setLocationRelativeTo(null);
frame.setVisible(true);
    </code></pre>
    
    <h3>JPanel vs. JComponent</h3>
    <p>
        <strong>JPanel</strong>:
    </p>
    <ul>
        <li>
            Used as a container to group and organize other components
        </li>
        <li>
            Has a default layout manager (FlowLayout) which can be changed as needed
        </li>
    </ul>
    <p>
        <strong>JComponent</strong>:
    </p>
    <ul>
        <li>
            The base class for most Swing components
        </li>
        <li>
            Typically extended to create custom components where you override the <code style="color:red">paintComponent</code> method for custom drawing
        </li>
        <li>
            Does not come with a layout manager by default
        </li>
    </ul>
    
    <h3>When to Use Which</h3>
    <p>
        Use <code style="color:red">JPanel</code> when you need a container to hold and organize multiple components using a layout manager. 
        Use <code style="color:red">JComponent</code> when you need a custom drawing area or a component with specialized painting behavior. 
        Often, you'll extend <code style="color:red">JComponent</code> to create custom graphics and then add that component to a <code style="color:red">JPanel</code> if you need to combine it with other controls.
    </p>
    
    <h3>Example: Custom Component in a Panel</h3>
    <p>
        Below is an example demonstrating a custom component (extending <code style="color:red">JComponent</code>) added to a <code style="color:red">JPanel</code> 
        that is then added to a <code style="color:red">JFrame</code>:
    </p>
    <pre><code>
import javax.swing.*;
import java.awt.*;

// Custom component with custom painting
class MyCustomComponent extends JComponent {
@Override
protected void paintComponent(Graphics g) {
    super.paintComponent(g);
    // Custom drawing code here
    g.setColor(Color.BLUE);
    g.fillRect(10, 10, 80, 80);
}
}

// JPanel used as a container for components
class MyPanel extends JPanel {
public MyPanel() {
    // Add a label and a custom component
    add(new JLabel("Hello Swing!"));
    add(new MyCustomComponent());
}
}

public class MainApp {
public static void main(String[] args) {
    JFrame frame = new JFrame("My Application");
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.setLayout(new BorderLayout());
    frame.add(new MyPanel(), BorderLayout.CENTER);
    frame.pack();
    frame.setLocationRelativeTo(null);
    frame.setVisible(true);
}
}
    </code></pre>
    
    <p>
        This example shows how you can combine standard containers (<code>JPanel</code>) with custom components (<code>JComponent</code>) and manage them within a <code>JFrame</code> using layout managers.
    </p>
</section>

<section id="screens">
  <h2 style="color:black">Navigating Between Screens</h2>

  <h3>1. Multiple JFrames Approach</h3>
  <p>
    You can create a dedicated <code>JFrame</code> for your welcome screen and another for your game.  
    When the user clicks “Start” you instantiate the game frame and close the welcome frame.
  </p>
  <pre><code>// In your WelcomeFrame class:
startButton.addActionListener(e -&gt; {
    // 1) Launch the game window
    GameFrame game = new GameFrame();
    game.setVisible(true);

    // 2) Close the welcome window
    this.dispose();
});</code></pre>


  <h3>2. Single JFrame + CardLayout</h3>
  <p>
    Embed all “screens” as cards in one main frame.  Switch between them via <code>CardLayout.show(...)</code>.
  </p>
  <pre><code>// In your MainFrame class:
CardLayout cardLayout = new CardLayout();
JPanel cards = new JPanel(cardLayout);

// Add two cards: welcome and game
cards.add(new WelcomePanel(cardLayout, cards), "WELCOME");
cards.add(new GamePanel(),                   "GAME");

this.add(cards);
cardLayout.show(cards, "WELCOME");

// In WelcomePanel’s constructor:
startButton.addActionListener(e -&gt; {
    cardLayout.show(parentPanel, "GAME");
});</code></pre>
  <ul>
    <li><strong>Pros:</strong> single window, smooth transitions, easy state sharing</li>
    <li><strong>Cons:</strong> slightly more initial setup</li>
  </ul>

  
</section>

<section id="levels">
  <h2 style="color:black">Implementing <code style="color:red">LevelIO.loadLevel</code> with <code style="color:red">BufferedReader</code></h2>

  <p>
    Since we have just learned to read text files with <code style="color:red">BufferedReader</code>, here is how to build a <code style="color:red">loadLevel(…)</code> method that reads your level file line-by-line and returns a simple <code style="color:red">Level</code> object.
  </p>

  <h3>Step 1: Define your Level model</h3>
  <pre><code>
public class Level {
    private final List&lt;String&gt; rows;
    public Level(List&lt;String&gt; rows) {
        this.rows = rows;
    }
    public List&lt;String&gt; getRows() { return rows; }
    // you can add helpers: getWidth(), getHeight(), charAt(row,col)…
}
  </code></pre>

  <h3>Step 2: Implement loadLevel</h3>
  <pre><code>
public class LevelIO {
    /**
     * Reads a text file, collects each non-blank line into a List,
     * then constructs and returns a Level.
     * Use our practice with FileIO
     */
    public static Level loadLevel(String filename) {
        List&lt;String&gt; rows = new ArrayList&lt;&gt;();
        File file = new File(filename);
        if (!file.exists()) {
            throw new RuntimeException("Level file not found: " + filename);
        }
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (!line.isEmpty()) {
                    rows.add(line);
                }
            }
        } catch (IOException e) {
            throw new RuntimeException("Error reading level file: " + e.getMessage(), e);
        }
        return new Level(rows);
    }
}
  </code></pre>

  <h3>Step 3: Using your new loadLevel in the game. You can make a folder if you have many levels (place in java project level, not in package level)</h3>
  <pre><code>
SwingUtilities.invokeLater(() -&gt; {
    Level level = LevelIO.loadLevel("levels/level1.txt");
    GamePanel panel = new GamePanel(level);
    JFrame frame = new JFrame("My Game");
    frame.add(panel);
    // … setup frame …
});
  </code></pre>

  <h3>Key Points</h3>
  <ul>
    <li>We read each line from the file until <code style="color:red">readLine()</code> returns <code style="color:red">null</code></li>
    <li>Blank or whitespace-only lines are skipped via <code style="color:red">trim().isEmpty()</code></li>

  </ul>
</section>

<section id="sprites">
  <h2 style="color:black">Reusing a Single Image for Multiple Sprites</h2>
  <p> So you have the same image but want to crate multiple Rock objects (as an example).
    You should load the same image file once into a <code style="color:red">BufferedImage</code>, and then share that in every rock you draw.
  </p>

  <h3>Why Load Once?</h3>
  <ul>
    <li><strong>Performance:</strong> Disk/IO and image‐decoding are expensive operations.</li>
    <li><strong>Memory:</strong> You avoid keeping duplicate pixel data in memory.</li>
    <li><strong>Simplicity:</strong> Easier to manage a single shared resource than many duplicates.</li>
  </ul>

  <h3>How to Do It</h3>
  <p>
    Put your image‐loading code in a static field, then each <code>Rock</code> simply references that one image.
  </p>
  <pre><code>public class Rock {
    private static BufferedImage rockSprite;
    static {
      try {
        rockSprite = ImageIO.read(
          Rock.class.getResource("/images/rock.png")
        );
      } catch (IOException e) {
        System.err.println("Failed to load rock sprite: " + e);
      }
    }

    private int x, y;

    public Rock(int x, int y) {
      this.x = x;
      this.y = y;
    }

    public void draw(Graphics g) {
      g.drawImage(rockSprite, x, y, null);
    }
  }</code></pre>

  

  <h3>Key Takeaway</h3>
  <p>
    Load once, reuse everywhere.
  </p>
</section>

  <section id="transform">
    <h2 style="color:black">Translation and Rotation in Java Swing</h2>
    <p>
        In Java Swing, you can use the <code style="color:red">Graphics2D</code> class to manipulate the coordinate system.
        Two common operations are <code style="color:red">translate</code> (to move the origin) and <code style="color:red">rotate</code> (to rotate the drawing context).
        This allows you to reposition and reorient your drawings easily.
    </p>
    
    <h3>Translation Example</h3>
    <p>
        The example below shows how to translate the graphics context to the center of the panel:
    </p>
    <pre><code>
int xOffset = getWidth() / 2;
int yOffset = getHeight() / 2;
g2d.translate(xOffset, yOffset);
    </code></pre>
    
    <h3>Rotation Example</h3>
    <p>
        You can rotate the coordinate system. Here is how you rotate by 45 degrees:
    </p>
    <pre><code>
g2d.rotate(Math.toRadians(45));
    </code></pre>
    <h3>Undoing Transformation</h3>
        <p>
            There are two common approaches to undo transformations:
        </p>
        <ol>
            <li>
                <strong>Using Negative Values:</strong> You can undo a translation or rotation by applying the opposite operation:
                <pre><code>
g2d.translate(-xOffset, -yOffset);
g2d.rotate(-Math.toRadians(45));
                </code></pre> 
               
            </li>
            <li>
                <strong>Using <code style="color:red">getTransform</code> and <code style="color:red">setTransform</code>:</strong> 
 <pre><code>
// Save the original transformation
AffineTransform originalTransform = g2d.getTransform();

// restore the original
g2d.setTransform(originalTransform);
 </code></pre>               
               
            </li>
        </ol>

  </section>
  <section id="threads">
    <h2 style="color:black">Getting Started &amp; Swing Threading</h2>
    <p>
      All Swing UI work must run on the Event Dispatch Thread (EDT) to avoid race conditions
      and deadlocks. Use <code style="color:red">SwingUtilities.invokeLater(…)</code> in your <code style="color:red">main</code>
      to kick off any UI creation.
    </p>
    <pre><code>// Example: launching your GUI on the EDT
import javax.swing.*;

public class App {
  public static void main(String[] args) {
    SwingUtilities.invokeLater(() -> {
      MyFrame frame = new MyFrame();
      frame.setVisible(true);
    });
  }
}
</code></pre>
    <p>
      <strong>Why?</strong> Swing is not thread‑safe—any long task or direct modifications
      off the EDT can freeze or corrupt your UI.
    </p>
  </section>

  <section id="jframe">
    <h2 style="color:black">Creating Your Window (<code style="color:red">JFrame</code>)</h2>
    <p>
      A <code style="color:red">JFrame</code> is the top‑level window for your application.
      You configure title, size, default close behavior, and add your custom components.
    </p>
    <pre><code>import javax.swing.*;
import java.awt.Dimension;

public class MyFrame extends JFrame {
  public MyFrame() {
    super("My Swing App");
    setDefaultCloseOperation(EXIT_ON_CLOSE);
    setPreferredSize(new Dimension(600, 400));
    // add your drawing panel or other components here:
    setContentPane(new MyDrawingPanel());
    pack();            // sizes frame to fit contents
    setLocationRelativeTo(null);  // centers on screen
  }
}
</code></pre>
    <p>
      <strong>Key calls:</strong>
      <ul>
        <li><code style="color:red">setDefaultCloseOperation(EXIT_ON_CLOSE)</code> to exit on close</li>
        <li><code style="color:red">pack()</code> vs. <code style="color:red">setSize(…)</code> &mdash; pack sizes to match child
            components’ preferred sizes</li>
        <li><code style="color:red">setLocationRelativeTo(null)</code> to center the window</li>
      </ul>
    </p>
  </section>

  <section id="painting">
    <h2 style="color:black">Custom Painting with <code style="color:red">JComponent</code></h2>
    <p>
      For graphics you subclass <code style="color:red">JComponent</code> (or <code style="color:red">JPanel</code>) and override
      <code style="color:red">paintComponent(Graphics)</code>. Always call <code style="color:red">super.paintComponent(g)</code>
      first, then cast to <code style="color:red">Graphics2D</code> for richer APIs.
    </p>
    <pre><code>import javax.swing.*;
import java.awt.*;

public class MyDrawingPanel extends JPanel {
  @Override
  protected void paintComponent(Graphics g) {
    super.paintComponent(g);
    Graphics2D g2 = (Graphics2D) g;

    // draw a filled rectangle
    Color old = g2.getColor();
    g2.setColor(Color.ORANGE);
    g2.fillRoundRect(50, 50, 200, 100, 20, 20);
    g2.setColor(old);

    // draw a string
    g2.drawString("Hello, Swing!", 100, 120);
  }
}
</code></pre>
    <p>
      <strong>Tips:</strong>
      <ul>
        <li>Save and restore <code>Graphics2D</code> state when you change color, stroke, or transform</li>
        
      </ul>
    </p>
  </section>
<section id="swinggraphics">
  <h1 style="color:black">Swing Graphics: Drawing with <code>paintComponent</code></h1>
  <p>
    In Java, <strong>Swing</strong> provides a simple way to create custom graphics. 
    All drawing is done using the <code style="color:red">Graphics</code> object, 
    which acts like a "pen" or "brush" that Swing passes into your component's 
    <code style="color:red">paintComponent()</code> method.
  </p>

  <h3>Basic Setup</h3>
  <p>
    To draw shapes or text, we usually create a <code style="color:red">JPanel</code> or <code style="color:red">JComponent</code> subclass 
    and override its <code style="color:red">paintComponent(Graphics g)</code> method:
  </p>
  <pre><code>import javax.swing.*;
import java.awt.*;

class MyPanel extends JPanel {
    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);  // clear background

        g.setColor(Color.BLUE);
        g.fillRect(50, 50, 100, 60);   // filled rectangle

        g.setColor(Color.RED);
        g.drawOval(200, 50, 80, 80);   // outlined oval

        g.setColor(Color.BLACK);
        g.drawString("Hello, Swing!", 50, 150); // text
    }
}

public class GraphicsDemo {
    public static void main(String[] args) {
        JFrame frame = new JFrame("Drawing Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(400, 300);
        frame.add(new MyPanel());
        frame.setVisible(true);
    }
}
</code></pre>

  <h3>Common Drawing Methods</h3>
  <p>
    The <code style="color:red">Graphics</code> (or <code style="color:red">Graphics2D</code>) 
    class provides many methods for drawing shapes, images, and text:
  </p>
  <ul>
    <li><code style="color:red">g.drawLine(x1, y1, x2, y2)</code> → Draws a line</li>
    <li><code style="color:red">g.drawRect(x, y, width, height)</code> → Outline rectangle</li>
    <li><code style="color:red">g.fillRect(...)</code> → Filled rectangle</li>
    <li><code style="color:red">g.drawOval(...)</code> / <code style="color:red">g.fillOval(...)</code> → Ovals</li>
    <li><code style="color:red">g.drawString("text", x, y)</code> → Text</li>
    <li><code style="color:red">g.drawImage(img, x, y, this)</code> → Draw an image</li>
  </ul>

  <h3>Colors and Fonts</h3>
  <p>
    You can change the pen color and font before drawing:
  </p>
  <pre><code>g.setColor(Color.MAGENTA);
g.fillOval(100, 200, 60, 60);

g.setFont(new Font("Serif", Font.BOLD, 24));
g.drawString("Styled Text", 180, 220);
</code></pre>

  <h3>Key Points to Remember</h3>
  <ul>
    <li>Always override <code style="color:red">paintComponent(Graphics g)</code>, not <code style="color:red">paint()</code>.</li>
    <li>Always call <code style="color:red">super.paintComponent(g)</code> first to clear the background.</li>
    <li>Use <code style="color:red">repaint()</code> to ask Swing to redraw when state changes (e.g., for animation).</li>
  </ul>
</section>
  <section id="events">
    <h2 style="color:black">Swing Components &amp; Event Handling</h2>
    <p>
      Most UIs combine drawing with interactive controls. Swing components like
      <code style="color:red">JButton</code>, <code style="color:red">JTextField</code>, etc., fire events you handle
      by registering listeners.
    </p>
    <pre><code>import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class InteractivePanel extends MyDrawingPanel {
  private JButton clearBtn;

  public InteractivePanel() {
    setLayout(new BorderLayout());
    clearBtn = new JButton("Clear");
    add(clearBtn, BorderLayout.SOUTH);

    // handle button clicks
    clearBtn.addActionListener(e -> {
      // e.g., clear internal state and repaint
      // someGraphicsModel.clear();
      repaint();
    });
  // handle keys
  frame.addKeyListener(new java.awt.event.KeyAdapter() {
    @Override
    public void keyPressed(java.awt.event.KeyEvent e) {
      switch(e.getKeyCode()) {
      case KeyEvent.VK_LEFT:
        canvas.moveDelta(-10); break;
      case KeyEvent.VK_RIGHT:
        canvas.moveDelta(+10); break;
      }
    }
  });
    // handle mouse clicks
    addMouseListener(new MouseAdapter() {
      @Override
      public void mousePressed(MouseEvent e) {
        // e.getX(), e.getY() can be used to draw shapes at click
        repaint();
      }
    });
  }
}
</code></pre>
    <p>
      <strong>Key points:</strong>
      <ul>
        <li>Use lambdas (Java 8+) or anonymous inner classes for listeners</li>
        <li>Fire <code style="color:red">repaint()</code> after any state change 
          to redraw your component</li>
      </ul>
    </p>
  </section>
  <section id="listener">
    <h3 style="color:black">Understanding Listener with <code style="color:darkred">getActionCommand()</code></h3>
    <p>
      When a shared <code style="color:darkred">ActionListener</code> handles multiple buttons, 
      <code style="color:darkred">e.getActionCommand()</code> tells you exactly which button was clicked without comparing objects.
    </p>
    <h4>1. Default Behavior</h4>
    <p>
      By default, a <code style="color:darkred">JButton</code>’s action command is the same as its label:
    </p>
    <pre><code>
  JButton up = new JButton("Count Up");
  // clicking this button -> e.getActionCommand() returns "Count Up"
    </code></pre>
    <h4>2. Customizing the Command</h4>
    <p>
      You can decouple the visible text from the command string:
    </p>
    <pre><code>
  JButton saveBtn = new JButton("Save File");
  saveBtn.setActionCommand("SAVE");
  // now e.getActionCommand() returns "SAVE",
  // even if you later change the button’s label
    </code></pre>
    <h4>3. Handling Multiple Buttons</h4>
    <p>
      Inside <code style="color:darkred">actionPerformed(ActionEvent e)</code>, 
      switch on the command:
    </p>
    <pre><code>
  public void actionPerformed(ActionEvent e) {
    switch (e.getActionCommand()) {
      case "UP":
        count++;
        break;
      case "DOWN":
        count--;
        break;
      case "RESET":
        count = 0;
        break;
    }
    text.setText(count + "");
  }
    </code></pre>
    <h4>4. Why Use It?</h4>
    <ul>
      <li><strong>Simplicity:</strong> One listener class, no need for separate listeners per button</li>
      <li><strong>Flexibility:</strong> Change the button’s label without breaking your logic</li>
      <li><strong>Localization:</strong> Display text in different languages, but keep a fixed internal command</li>
    </ul>
  </section>

  <section id="images">
    <h2 style="color:black">Adding Images</h2>
    <p>
      You can load and display images in a Swing or JavaFX application using the <code style="color:red">ImageIO</code> class. 
      Below is a simple example showing how to read a PNG or JPEG file and draw it inside a <code style="color:red">JPanel</code>. 
    </p>
    <p>You can create a folder under "src" and called it images. Then you path to the image will be "src/images/imagename.png"</p>
    <pre><code>
  // In a class that extends JPanel:
  
  private BufferedImage image;
  
  public MyImagePanel() {
      try {
          image = ImageIO.read(new File("path/to/image.png"));
      } catch (IOException e) {
          e.printStackTrace();
      }
  }
  
  @Override
  protected void paintComponent(Graphics g) {
      super.paintComponent(g);
      if (image != null) {
          // Draw at top-left corner (0,0)
          g.drawImage(image, 0, 0, this); // this is your panel
      }
  }
    </code></pre>
    
  </section>

<section id="swing-timer">
  <h2 style="color:black">Swing Timer - Game Loops</h2>
  <p>
    A <code style="color:red">javax.swing.Timer</code> fires an action event on a fixed schedule
    (e.g., every 30 ms) on the Swing Event Dispatch Thread (EDT). In each tick,
    you (1) update your model (positions, states) and (2) call <code>repaint()</code>.
    That’s your whole animation/game loop.
  </p>

  <details class="hint">
    <summary>💡 Why <code style="color:red">javax.swing.Timer</code> (not <code style="color:red">java.util.Timer</code>)?</summary>
    <p>
      <code style="color:red">javax.swing.Timer</code> runs on the EDT and plays nicely with Swing painting.
      <code style="color:red">java.util.Timer</code> runs on a background thread and can cause UI race conditions.
      For Swing apps, prefer <code style="color:red">javax.swing.Timer</code>.
    </p>
  </details>

  <h3>Minimal Pattern</h3>
  <pre><code>Timer timer = new Timer(30, e -&gt; {
    // 1) update model
    ball.move(getWidth(), getHeight());
    // 2) request repaint (asynchronous)
    repaint();
});
timer.start();   // timer.stop() to pause</code></pre>

  <details class="hint">
    <summary>Timer model</summary>
    <p>
      Think of the Timer as “call this code ~33 times per second.” Your job inside each tick:
      make small changes (like position += velocity) and ask Swing to redraw.
    </p>
  </details>

  <h3>Speed: Frame Rate vs. Velocity</h3>
  <p>
    Two dials control how fast things look:
  </p>
  <ul>
    <li><strong>Frame rate</strong> = Timer delay. Smaller delay → more updates/sec → smoother/faster.</li>
    <li><strong>Velocity</strong> = your per-tick movement (e.g., <code>dx, dy</code>). Larger values → bigger jumps each tick.</li>
  </ul>
  <pre><code>// Higher frame rate (about 60 FPS)
Timer timer60 = new Timer(16, e -&gt; updateAndRepaint());

// Lower frame rate (about 20 FPS)
Timer timer20 = new Timer(50, e -&gt; updateAndRepaint());

// Same frame rate, different speed (velocity change)
ball.dx = 5; ball.dy = 0;  // faster horizontal
ball.dx = 2; ball.dy = 1;  // slower diagonal</code></pre>

  <details class="hint">
    <summary>🎯 Which should I change?</summary>
    <p>
      Prefer a consistent frame rate (e.g., 16–33 ms) and change velocity for gameplay feel.
      Only change the delay if you specifically want a different update frequency.
    </p>
  </details>

  <h3>Adding Timers to Objects (Two Patterns)</h3>

  <h4>Pattern A — Per-Object Timer (simple demos)</h4>
  <p>Give the object its own timer. Great for isolated animations or teaching encapsulation.</p>
  <pre><code>public class Blinker extends JComponent {
  private boolean on = false;
  private final Timer timer;

  public Blinker() {
    setPreferredSize(new Dimension(60, 60));
    timer = new Timer(300, e -&gt; { on = !on; repaint(); });
    timer.start();
  }

  @Override protected void paintComponent(Graphics g) {
    super.paintComponent(g);
    g.setColor(on ? Color.GREEN : Color.GRAY);
    g.fillOval(10, 10, 40, 40);
  }
}</code></pre>

  <details class="hint">
    <summary>Pros / Cons</summary>
    <p><strong>Pros:</strong> super easy; object controls its own animation.<br>
       <strong>Cons:</strong> many objects ⇒ many timers. For games with lots of entities, use one shared loop.</p>
  </details>

  <h4>Pattern B — One Shared Timer (recommended for games)</h4>
  <p>Keep a single “game loop” in your component/panel; update all objects each tick.</p>
  <pre><code>public class GameComponent extends JComponent {
  private final java.util.List&lt;Ball&gt; balls = new java.util.ArrayList<>();
  private final Timer loop = new Timer(16, e -&gt; tick());

  public GameComponent() {
    setPreferredSize(new Dimension(500, 300));
    balls.add(new Ball(100, 120));
    balls.add(new Ball(240, 80));
    loop.start();
  }

  private void tick() {
    for (Ball b : balls) b.move(getWidth(), getHeight());
    repaint();
  }

  @Override protected void paintComponent(Graphics g) {
    super.paintComponent(g);
    var g2 = (Graphics2D) g;
    for (Ball b : balls) b.draw(g2);
  }
}</code></pre>

  <details class="hint">
    <summary>💡 Start/Stop controls (Space bar)</summary>
    <p>Expose <code>start()</code>/<code>stop()</code> methods and bind to keys.</p>
    <pre><code>public void start() { if (!loop.isRunning()) loop.start(); }
public void stop()  { if (loop.isRunning()) loop.stop(); }</code></pre>
    <p>In your <code>GamePanel</code> key handler:</p>
    <pre><code>case KeyEvent.VK_SPACE -&gt; {
  if (canvas.loop.isRunning()) canvas.stop();
  else canvas.start();
}</code></pre>
  </details>

  <h3>Example: Minimal Moving Ball (wrap-around)</h3>
  <pre><code>public class Ball {
  int x, y, dx = 3, dy = 2, radius = 15;
  Color color = Color.RED;
  public Ball(int x, int y) { this.x = x; this.y = y; }

  public void move(int width, int height) {
    x += dx; y += dy;
    if (x &lt; 0) x = width;
    if (x &gt; width) x = 0;
    if (y &lt; 0) y = height;
    if (y &gt; height) y = 0;
  }

  public void draw(Graphics2D g2) {
    g2.setColor(color);
    g2.fillOval(x - radius, y - radius, radius * 2, radius * 2);
  }
}</code></pre>

  <details class="hint">
    <summary>🔁 Bounce instead of wrap (optional)</summary>
    <p>Flip velocity when touching an edge:</p>
    <pre><code>if (x - radius &lt; 0 || x + radius &gt; width)  dx = -dx;
if (y - radius &lt; 0 || y + radius &gt; height) dy = -dy;</code></pre>
  </details>

  <h3>Common Pitfalls</h3>
  <ul>
    <li><strong>No repaint:</strong> If nothing moves, ensure you call <code>repaint()</code> in every tick.</li>
    <li><strong>Focus issues:</strong> Key events need focus: <code>setFocusable(true)</code> and <code>requestFocusInWindow()</code>.</li>
    <li><strong>EDT safety:</strong> Create/show UI on the EDT: <code>SwingUtilities.invokeLater(...)</code>.</li>
    <li><strong>Multiple timers:</strong> Avoid stacking multiple loops by accident; check <code>isRunning()</code> before start/stop.</li>
  </ul>

  <details class="hint">
    <summary>🧰 Quick Starter Snippet</summary>
    <pre><code>// In GameComponent constructor:
Timer timer = new Timer(30, e -&gt; { update(); repaint(); });
timer.start();

// In paintComponent:
@Override protected void paintComponent(Graphics g) {
  super.paintComponent(g);
  // draw your stuff...
}</code></pre>
  </details>
</section>


  <section id="focus">
    <h2 style="color:black"><code style="color:darkred">requestFocusInWindow()</code></h2>
    <p>
      In Swing, only the component that has keyboard focus receives key events.  
      When you click a button, focus moves to that button, so your frame or canvas loses arrow‐key control.
    </p>
    <h3>What it does</h3>
    <ul>
      <li>
        <code style="color:darkred">requestFocusInWindow()</code> asks the windowing system to give <em>this</em> component the focus as soon as it’s safe.  
      </li>

    </ul>
    <h3>Typical usage</h3>
    <pre><code>
  // after showing your frame or panel:
  canvas.requestFocusInWindow();
  
  // or, in a button callback:
  parentFrame.requestFocusInWindow();
    </code></pre>
    <p>
      Call it <strong>after</strong> you change UI state (e.g. in your <code style="color:darkred">moveLeft()</code> / <code style="color:darkred">moveRight()</code> methods) so that immediately following the click, your frame/canvas can once again receive arrow‐key events.
    </p>
  </section>


  <section id="abstract">
    <h2 style="color:black">Abstract Classes</h2> 
    <p> An <code style="color:darkred">abstract</code> class in Java is declared with the <code style="color:darkred">abstract</code> modifier and cannot be instantiated directly.
      It serves as a partial blueprint for its subclasses</p> 
      <p> Abstract classes may include both <em>abstract methods</em> (without bodies) and <em>concrete methods</em> (with implementations), 
        as well as instance fields and constructors to initialize shared state</p> 
        <p> Use an abstract class when you want to share code or data among related classes while forcing them to implement specific behaviors</p> 
        <h3>Example</h3> 
        <pre><code> // Abstract base class 
public abstract class Shape { 
  protected String color; 
  protected Shape(String color) { 
    this.color = color; 
  } 
  public abstract double area(); // abstract method 
  public void describe() { 
    // concrete method 
    System.out.println("Color: " + color + ", area=" + area()); 
   } 
}
// Concrete subclass 
public class Circle extends Shape {
  private double radius;
  public Circle(String color, double radius) {
    super(color); 
    this.radius = radius; 
    } 
  @Override
  public double area() {
    return Math.PI * radius * radius;
   }
} </code></pre>
    
    </section>

    <section id="upcast"> <h2 style="color:black">Upcasting &amp; Downcasting</h2> 
      <p> <strong>Upcasting</strong> converts a <em>subclass</em> reference to a <em>superclass</em> type implicitly (no cast syntax is needed) and is always safe 
        because every instance of the subclass <em>is-a</em> instance of its superclass</p> 
        <p> <strong>Downcasting</strong> converts a <em>superclass</em> reference back to a <em>subclass</em> type and must be done explicitly with this syntax <code style="color:darkred">(Type)</code> operator; 
          the JVM checks at runtime and throws <code style="color:darkred">ClassCastException</code> if the object is not actually of that subtype</p> 
          <h3>Examples</h3> 
          <pre><code> // Upcasting (implicit) 
  Animal a = new Dog(); // no cast, always safe

  // Downcasting (explicit) 
    Dog d = (Dog) a; // JVM checks at runtime 
</code></pre>
      
      </section> 
      <section id="errors"> 
        <h2 style="color:black">Compile-Time vs. Run-Time Errors</h2> 
        <p> A <strong>compile-time error</strong> is detected by the Java compiler when code violates syntax or static typing rules.
          For example, missing semicolons or illegal casts between unrelated types</p> 
<p> A <strong>run-time error</strong> occurs during program execution after successful compilation.
  Examples include <code style="color:darkred">NullPointerException</code> or <code style="color:darkred">ClassCastException</code> when logic or environment causes failure</p>
<pre><code> public class Demo { 
  public static void main(String[] args) { 
    String s = null; 
    System.out.println(s.length()); // throws NullPointerException at runtime 
  } 
} </code></pre> 
</section>
<button id="toTop" aria-label="Back to top">⬆ To Top</button>
<script>
  const toTop = document.getElementById("toTop");
  const showAfter = 300; // px

  window.addEventListener("scroll", () => {
    if (window.scrollY > showAfter) toTop.classList.add("show");
    else toTop.classList.remove("show");
  });

  toTop.addEventListener("click", () => {
    const start = window.scrollY;
    const duration = 800; // ms
    const startTime = performance.now();

    function animateScroll(currentTime) {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const ease = 1 - Math.pow(1 - progress, 3); // ease-out cubic
      window.scrollTo(0, 0);

      if (elapsed < duration) requestAnimationFrame(animateScroll);
    }
    requestAnimationFrame(animateScroll);
  });
</script>
  </body>
</html>