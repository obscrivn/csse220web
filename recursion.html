<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Recursion Tips & Patterns</title>
      <link rel="stylesheet" type="text/css" href="./syllabus_files/screen.css">
<link rel="stylesheet" type="text/css" href="./syllabus_files/schedule.css">
<link rel="icon" type="image/x-icon" href="favicon.ico">
  <style>
    :root{
      --ink:#1f2937;/* slate-800 */
      --muted:#6b7280;/* gray-500 */
      --accent:#2563eb;/* blue-600 */
      --bg:#ffffff;
      --card:#f8fafc;/* slate-50 */
      --code:#0f172a;/* slate-900 */
      --chip:#eef2ff;/* indigo-50 */
    }
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      /* padding: 0; */
      padding-top: 0;
    }
   /* html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"}
    /* Header styling */
#header {
position: fixed;
top: 0;
left: 0;
right: 0;
z-index: 1000;

padding: 0.8rem 1rem;
}
#header a {
color: #fff;
margin-right: 15px;
text-decoration: none;
font-weight: 600;
}
#header a:hover {
text-decoration: underline;
}
#header div {
clear: both;
}
.badge {
background: #fef3c7;
color: #78350f;
border-radius: 999px;
padding: 0.2rem 0.6rem;
font-size: 0.8rem;
font-weight: bold;
}
main {
padding: 20px;
margin-top: 120px;
}
   /* main{max-width:1100px;margin:0 auto;padding:2rem 1rem 4rem; padding: 20px;}*/
    h1{font-size:2rem;margin:.2rem 0 1rem}
    h2{margin:2rem 0 .5rem}
    h3{margin:1.2rem 0 .4rem}
    .lead{color:var(--muted)}
    .grid{display:grid;gap:1rem}
    @media (min-width:900px){.grid-2{grid-template-columns:1fr 1fr}.grid-3{grid-template-columns:1fr 1fr 1fr}}
    .card{background:var(--card);border:1px solid #e5e7eb;border-radius:16px;padding:1rem}
    .callout{border-left:4px solid var(--accent);background:#eff6ff;padding:0.75rem 1rem;border-radius:8px}
    code,kbd,pre{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    pre{background:#0b1220;color:#d1d5db;border-radius:12px;padding:1rem;overflow:auto}
    .table{width:100%;border-collapse:collapse}
    .table th,.table td{border:1px solid #e5e7eb;padding:.6rem;text-align:left;vertical-align:top}
    .chips{display:flex;flex-wrap:wrap;gap:.5rem}
    .chip{background:#f1f5f9;border:1px solid #e2e8f0;padding:.25rem .5rem;border-radius:999px;font-size:.85rem}
    details{background:#f9fafb;border:1px solid #eceff3;border-radius:12px;padding:.6rem 1rem}
    details summary{cursor:pointer;font-weight:600}
    .small{font-size:.9rem;color:var(--muted)}
    .kbd{border:1px solid #e5e7eb;border-bottom-width:2px;border-radius:6px;padding:.1rem .35rem;background:#fff}
  </style>
</head>
<body>

    <div id="header">
                <a id="index_link" href="./index.html">CSSE 220</a>
                <a id="syllabus_link" href="./syllabus.html">Syllabus</a>
                <a id="schedule_link" href="./schedule.html">Schedule</a>
                <a id="quiz_link" href="./demos.html">Demos</a>
                <a id="quiz_link" href="./worksheets.html">Quizzes</a>
                <a id="quiz_link" href="./labs.html">Labs</a>
                <a id="quiz_link" href="./homework.html">Homework</a>
                <a id="quiz_link" href="./exams.html">Exams</a>
                <a id="quiz_link" href="./project.html">Final Project</a>
                <a id="resources_link" href="./resources.html">Resources</a>
                <div style="clear:both;"></div>
   

</div>

  <main>
    <h1>Recursion Tips & Patterns</h1>
    <p class="lead">A fast, practical guide to mastering recursion for CSSE 220. Use this page before quizzes, labs, and exams. Includes base-case patterns, boolean logic (AND/OR), array/string templates, and example solutions.</p>

    <section class="card">
      <h2>Quick-Start Cheatsheet</h2>
      <div class="grid grid-3">
        <div>
          <h3>How to start</h3>
          <ul>
            <li><strong>Define the goal:</strong> What must this function return?</li>
            <li><strong>Find the simplest case:</strong> empty / last / zero â†’ return a neutral value.</li>
            <li><strong>Shrink the problem:</strong> move to <code>substring(1)</code>, <code>index+1</code>, or <code>n-1</code>.</li>
          </ul>
        </div>
        <div>
          <h3>Neutral values</h3>
          <div class="chips">
            <span class="chip">String build â†’ <code>""</code></span>
            <span class="chip">Counting â†’ <code>0</code></span>
            <span class="chip">Product/AND â†’ <code>1</code>/<code>true</code></span>
            <span class="chip">OR/search â†’ <code>false</code></span>
          </div>
        </div>
        <div>
  <h3>Golden pattern</h3>
<pre><code>return result_of_this_step + recurse(smaller_input);
</code></pre>
<p class="small">Examples:<br>
<code>count + recurse(...)</code><br>
<code>(cond) || recurse(...)</code><br>
<code>char + recurse(...)</code><br>
<code>(cond) && recurse(...)</code>
</p>          
        </div>
</div>
</section>





    <section>
<h2>Base-Case Cookbook</h2>

<h3>Strings</h3>
<ul>
  <li><b>No lookahead</b> (only use s.charAt(0)):
    <pre><code>if (s.isEmpty()) return "";</code></pre>
    Neutral value: <code>""</code>
  </li>
  <li><b>Needs 1 lookahead</b> (you will read s.charAt(1)):
    <pre><code>if (s.length() <= 1) return s;</code></pre>
    Avoids OOB when no pair exists
  </li>
  <li><b>Needs 2 lookahead</b> (you will read s.charAt(2)):
    <pre><code>if (s.length() <= 2) return s;</code></pre>
  </li>
</ul>

<p><i>Tip:</i> In Java, never use <code>==</code> for strings. Prefer <code>s.isEmpty()</code> or <code>s.equals("")</code>.</p>

<h3>Arrays (by index)</h3>
<table>
<tr><th>Access</th><th>Safe Base Case</th><th>Safe Index Range</th></tr>
<tr><td>nums[i]</td><td><code>if (i >= nums.length) return â€¦;</code></td><td>0..len-1</td></tr>
<tr><td>nums[i], nums[i+1]</td><td><code>if (i >= nums.length - 1) return â€¦;</code></td><td>0..len-2</td></tr>
<tr><td>nums[i], nums[i+1], nums[i+2]</td><td><code>if (i >= nums.length - 2) return â€¦;</code></td><td>0..len-3</td></tr>
</table>

<p><i>Why <code>&gt;=</code>?</i> It safely handles both the last valid index and empty arrays.</p>

<h3>ArrayList&lt;&gt;</h3>
<p><b>Base case:</b> use <code>isEmpty()</code> to stop when the list has no elements left.</p>

<pre><code>if (list.isEmpty()) return 0;     // for numeric sum
if (list.isEmpty()) return "";    // for string build
if (list.isEmpty()) return false; // for boolean search
</code></pre>
<h4>Example 1. Summing Integers (mutating)</h4>
<pre><code>int sumList(ArrayList&lt;Integer&gt; list) {
    if (list.isEmpty()) return 0;
    int first = list.remove(0);
    return first + sumList(list);
}
</code></pre>

<h4>Example 2. Building a String from Words (mutating)</h4>
<pre><code>String joinWords(ArrayList&lt;String&gt; words) {
    if (words.isEmpty()) return "";
    String first = words.remove(0);
    return first + " " + joinWords(words);
}
</code></pre>

<h4>Example 3. Counting a Condition (non-mutating, using index)</h4>
<pre><code>int countOdds(ArrayList&lt;Integer&gt; list, int i) {
    if (i == list.size()) return 0;
    int count = (list.get(i) % 2 != 0) ? 1 : 0;
    return count + countOdds(list, i + 1);
}
</code></pre>
<h3>Boolean Recursion Patterns (Quick Reminder)</h3>
<ul>
  <li><b>OR (search for any):</b> return <code>foundHere || recurse(...)</code></li>
  <li><b>AND (all must pass):</b> return <code>okHere &amp;&amp; recurse(...)</code></li>
</ul>
</section>
<section>
<hr>
<h2>Recursion with Helper Methods</h2>

<p><strong>Why use a helper?</strong>  
Sometimes a recursive problem needs <em>extra information</em> (like an index or a running total) that you donâ€™t want in the public methodâ€™s parameters.  
A <code>helper</code> method lets you hide those details while keeping your recursion clean and organized.</p>

<p>Typical reasons to use a helper:</p>
<ul>
  <li>Track progress with an index</li>
  <li>Accumulate partial results</li>
  <li>Hide technical parameters from the caller</li>
</ul>

<h4>General Pattern</h4>
<pre><code class="language-java">
public returnType methodName(parameters) {
    // Setup or validate input
    // Call helper with extra arguments
    return helper(parameters, extraInfo);
}

private returnType helper(type param1, type extraInfo) {
    if (base case) {
        return something;
    }
    // Recursive step using extraInfo
    return helper(updatedParam1, updatedExtraInfo);
}
</code></pre>

<h4>Example 1 â€“ Count Uppercase Letters</h4>
<p>We only want the user to pass in a <code>String</code>, not an index. The helper keeps track of where we are.</p>
<pre><code class="language-java">
public int countUppercase(String s) {
    return countUppercaseHelper(s, 0);
}

private int countUppercaseHelper(String s, int index) {
    if (index == s.length()) {
        return 0;
    }
    int count = Character.isUpperCase(s.charAt(index)) ? 1 : 0;
    return count + countUppercaseHelper(s, index + 1);
}
</code></pre>

<h4>Example 2 â€“ Sum of Digits</h4>
<pre><code class="language-java">
public int sumDigits(int n) {
    return sumDigitsHelper(Math.abs(n), 0);
}

private int sumDigitsHelper(int n, int sum) {
    if (n == 0) {
        return sum;
    }
    return sumDigitsHelper(n / 10, sum + n % 10);
}
</code></pre>

<p><strong>Why a helper?</strong> The helper tracks the running total instead of returning through the call stack.</p>

<h4>Example 3 â€“ Reverse a String</h4>
<pre><code class="language-java">
public String reverse(String s) {
    return reverseHelper(s, "");
}

private String reverseHelper(String s, String soFar) {
    if (s.isEmpty()) {
        return soFar;
    }
    return reverseHelper(s.substring(1), s.charAt(0) + soFar);
}
</code></pre>

<p>The helper accumulates the reversed portion in <code>soFar</code>.</p>

<h4>Design Tips</h4>
<table>
  <tr><th>When to use a helper</th><th>Why</th></tr>
  <tr><td>You need an index or accumulator variable</td><td>To track progress or partial results</td></tr>
  <tr><td>You want to simplify the user-facing method</td><td>Hide technical parameters</td></tr>
  <tr><td>You need multiple recursive calls with extra state</td><td>Maintain state cleanly between calls</td></tr>
</table>

</section>
    <!-- <section>

      <h2>Base-Case Patterns</h2>
      <div class="grid grid-2">
        <div class="card">
          <h3>Strings</h3>
          <table class="table">
            <thead><tr><th>Lookahead Need</th><th>Safe Base Case</th><th>Why</th><th>Examples</th></tr></thead>
            <tbody>
              <tr>
                <td>None (current char only)</td>
                <td><code>if (str.isEmpty()) return "";</code></td>
                <td>No chars left; neutral string is empty.</td>
                <td><code>noX</code>, <code>countX</code></td>
              </tr>
              <tr>
                <td>Needs next char</td>
                <td><code>if (str.length() &lt;= 1) return str;</code></td>
                <td>No pair exists; avoid <code>charAt(1)</code> OOB.</td>
                <td><code>allStar</code>, pair checks</td>
              </tr>
              <tr>
                <td>Needs two ahead</td>
                <td><code>if (str.length() &lt;= 2) return str;</code></td>
                <td>No triple exists; avoid <code>charAt(2)</code> OOB.</td>
                <td>triple patterns</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="card">
          <h3>Arrays (by index)</h3>
          <table class="table">
            <thead><tr><th>Access Pattern</th><th>Safe Base Case</th><th>Safe Index Range</th><th>Examples</th></tr></thead>
            <tbody>
              <tr>
                <td>Single element: <code>nums[i]</code></td>
                <td><code>if (i &gt;= nums.length) return ...;</code></td>
                <td><code>0..len-1</code></td>
                <td><code>array11</code> (counting/search)</td>
              </tr>
              <tr>
                <td>Pair: <code>nums[i], nums[i+1]</code></td>
                <td><code>if (i &gt;= nums.length - 1) return ...;</code></td>
                <td><code>0..len-2</code></td>
                <td><code>array220</code>, adjacency checks</td>
              </tr>
              <tr>
                <td>Triple: <code>nums[i], nums[i+1], nums[i+2]</code></td>
                <td><code>if (i &gt;= nums.length - 2) return ...;</code></td>
                <td><code>0..len-3</code></td>
                <td><code>array123</code> style</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <div class="callout small">ðŸ’¡ Use <strong><code>&gt;=</code></strong> in array base cases to cover both the last valid index <em>and</em> empty arrays safely.</div>
    </section> -->

    <!-- <section class="card">
<h2>Boolean Recursion (Intro Style)</h2>
<h3>OR pattern (search for any)</h3>
<pre><code>boolean contains11(int[] a, int i) {
if (i &gt;= a.length) {
return false; // base: nothing left â†’ not found
}


if (a[i] == 11) {
return true; // found at this step
}


// otherwise, check the rest
return contains11(a, i + 1);
}
</code></pre>
<h3>AND pattern (all must pass)</h3>
<pre><code>boolean allLower(String s) {
if (s.isEmpty()) {
return true; // base: no violations in empty string
}


char c = s.charAt(0);
if (!Character.isLowerCase(c)) {
return false; // found a violation
}


// otherwise, the rest must also be lower-case
return allLower(s.substring(1));
}
</code></pre>
</section> -->

    <section>
      <h2>Canonical Solutions (for practice)</h2>
      <div class="grid grid-2">
        <div class="card">
          <h3><code>noX</code> (remove all 'x')</h3>
<pre><code>String noX(String s){
  if (s.isEmpty()) return "";
  char c = s.charAt(0);
  String rest = noX(s.substring(1));
  return (c=='x') ? rest : c + rest;
}
</code></pre>
        </div>
        <div class="card">
          <h3><code>allStar</code> (insert '*')</h3>
<pre><code>String allStar(String s){
  if (s.length() &lt;= 1) return s; // need lookahead
  return s.charAt(0) + "*" + allStar(s.substring(1));
}
</code></pre>
        </div>
        <div class="card">
          <h3><code>array11</code> (count 11s)</h3>
<pre><code>int array11(int[] a, int i){
  if (i &gt;= a.length) return 0;
  int add = (a[i]==11) ? 1 : 0;
  return add + array11(a, i+1);
}
</code></pre>
        </div>
        <div class="card">
          <h3><code>array220</code> (next is 10Ã— current)</h3>
<pre><code>boolean array220(int[] nums, int index) {
if (index &gt;= nums.length - 1) {
return false; // base: need a pair (index and index+1)
}

int current = nums[index];
int next = nums[index + 1];
if (next == current * 10) {
return true; // found a valid pair
}

// otherwise, move forward
return array220(nums, index + 1);
}
</code></pre>
        </div>


        <div class="card">
          <h3><code>Helper Method Builder</code></h3>
<h5>Starter Code:</h5>
<pre><code class="language-java">
public boolean containsX(String s) {
    // TODO: use a helper with an index
}
</code></pre>
<h5>Transformed Version with a Helper:</h5>
<pre><code class="language-java">
public boolean containsX(String s) {
    return containsXHelper(s, 0);
}

private boolean containsXHelper(String s, int i) {
    if (i == s.length()) {
        return false;
    }
    if (s.charAt(i) == 'x') {
        return true;
    }
    return containsXHelper(s, i + 1);
}
</code></pre>

<p><strong>Pattern to Notice:</strong></p>
<ul>
  <li>The public method hides the index, it just calls the helper.</li>
  <li>The helper adds one parameter (<code>i</code>) to track progress through the string.</li>
  <li>The helper defines its own <em>base case</em> and <em>recursive step</em>.</li>
</ul>
        </div>
      </div>
    </section>

    <section>
      <h2>Trace Template (use with tiny inputs)</h2>
      <details open>
        <summary>Copy this for your notebook</summary>
<pre><code>// Example: array11([11,2,11], 0)
Call 0: i=0 â†’ (a[0]==11 ? 1 : 0) + array11(a,1)
Call 1: i=1 â†’ (a[1]==11 ? 1 : 0) + array11(a,2)
Call 2: i=2 â†’ (a[2]==11 ? 1 : 0) + array11(a,3)
Call 3: i=3 â†’ base â†’ 0
Unwind: Call2=1+0=1 â†’ Call1=0+1=1 â†’ Call0=1+1=2
</code></pre>
      </details>
    </section>

    <section>
      <h2>Common Pitfalls</h2>
      <ul>
        <li>For arrays with pair/triple access, use <strong><code>i &gt;= length-1</code></strong> / <strong><code>-2</code></strong> bases (empty arrays included).</li>
        <li>For strings that look ahead, prefer <strong><code>length() &lt;= 1</code></strong> (or <code>&lt;= 2</code> for triples) over <code>isEmpty()</code>.</li>
        <li>Every call must <em>shrink</em> the input (e.g., <code>i+1</code>, <code>substring(1)</code>, <code>n-1</code>), otherwise youâ€™ll stack overflow.</li>
      </ul>
    </section>

    <section>
      <h2>More Practice</h2>
      <p>Try additional small problems on <a href="https://codingbat.com/java">CodingBat</a> â†’ Java â†’ Recursion. Focus on writing the base case first, then combine current work with the smaller result.</p>
    </section>
</main>
</body>
</html>
