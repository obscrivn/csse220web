<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>CSSE 220</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
<link rel="stylesheet" type="text/css" href="../syllabus_files/schedule.css">
<link rel="stylesheet" type="text/css" href="../syllabus_files/screen.css">
<style>

body {
          font-family: Arial, sans-serif;
          line-height: 1.5;
          margin: 0;
          padding: 1rem;
          background: #f5f7fa;
          color: #333;
        }
        
        /* Section containers */
        section {
          background: #fff;
          border: 1px solid #ddd;
          border-radius: 6px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.05);
          margin: 1.5rem 0;
          padding: 1.2rem;
        }
        
        /* Headings */
        h2 {
          margin-top: 0;
          font-size: 1.6rem;
          border-bottom: 2px solid #e0e0e0;
          padding-bottom: 0.3rem;
        }
        h3 {
          font-size: 1.3rem;
          margin-top: 1rem;
        }
        
        /* Image styling */
        section img {
          display: block;
          max-width: 100%;
          height: auto;
          margin: 0.8rem auto;
          border: 1px solid #ccc;
          border-radius: 4px;
        }
        
        /* Code blocks */
        /* pre {
          background: #2d2d2d;
          color: #f8f8f2;
          padding: 0.8rem;
          border-radius: 1px;
          overflow-x: auto;
          font-family: "Courier New", Courier, monospace;
          font-size: 0.9rem;
        } */
        /* pre code {
          display: block;
          white-space: pre-wrap;
          word-wrap: break-word;
        } */
        
        /* Inline code */
        /* code {
          background: #eaeaea;
          color: #c7254e;
          padding: 0.2rem 0.4rem;
          border-radius: 1px;
          font-family: "Courier New", Courier, monospace;
          font-size: 0.95em;
        } */
        
        /* Highlight compile / runtime state */
        strong + span {
          font-weight: bold;
          color: #d14;
        }
        
        /* Lists */
        ul, ol {
          margin: 0.5rem 0 0.5rem 1.2rem;
        }
        li {
          margin-bottom: 0.5rem;
        }
        
        /* Method call subsections */
        section#method-calls h4 {
          margin: 1rem 0 0.3rem;
          font-size: 1.1rem;
          color: #444;
          border-left: 3px solid #007acc;
          padding-left: 0.5rem;
        }
        
        /* Emphasis for compile/run status */
        span[style*="darkred"] {
          font-weight: bold;
          color: #c00;
        }



    /* body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f5f5f5;
    } */
    #main-content {
      padding: 20px;
    }
/* Header styling */
#header {
        position: fixed;
        top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
    }
    #header a {
      color: #fff;
      margin-right: 15px;
      text-decoration: none;

    }
    #header a:hover {
      text-decoration: underline;
    }
    #header div {
      clear: both;
    }
    /* Content container */
    #content {
      padding: 20px;
      /* margin-top: 100px;  */
      margin-bottom: 50px;
      padding-top: 100px;
    }
    #section {
margin-top: 1rem; 
margin-bottom: 1rem;
padding: 20px;
} 
    .lab-section {
      background-color: #fff;
      border: 1px solid #ccc;
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 5px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
    }
    .lab-section h2 {
      border-bottom: 2px solid #ddd;
      padding-bottom: 5px;
      color: #333;
    }
    .lab-section p {
      line-height: 1.5;
      color: #555;
    }
/* Lab Navigation Menu Styling */
#lab-nav {
      background-color: #faf9fc;
      padding: 10px;
      margin-bottom: 20px;
      border: 1px solid #ccc;
      border-radius: 5px;
      overflow-x: auto;  /* Enables horizontal scroll */
      white-space: nowrap; /* Prevents wrapping */
    }
    #lab-nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
      display: flex;
      gap: 15px;
    }
    #lab-nav ul li a {
      text-decoration: none;
      color: #333;
      margin-left: 20px;
      padding: 5px 10px;
      border-radius: 3px;
    }
    #lab-nav ul li a:hover {
      background-color: #ddd;
    }
    code {
        color: red;
    }
    .code-window {
      background-color: #272822;
      color: #f8f8f2;
      border: 1px solid #333;
      padding: 10px;
      font-family: Consolas, "Courier New", monospace;
      white-space: pre;
      overflow-x: auto;
      border-radius: 3px;
      margin-top: 10px;
    }
    .solution-window {
      background-color: #e8f5e9;
      color: #2e7d32;
      border: 1px solid #4caf50;
      padding: 10px;
      font-family: Consolas, "Courier New", monospace;
      border-radius: 3px;
      overflow-x: auto;
      white-space: pre;
      margin-top: 10px;
    }
    .solution-header {
      font-weight: bold;
      margin-bottom: 5px;
      color: #2e7d32;
    }

    a.resource-ref {
  background-color: #444; /* dark background for contrast */
  color: #61dafb;         /* bright text color */
  padding: 4px 8px;
  border-radius: 4px;
  text-decoration: none;
  transition: background-color 0.2s ease;
}

a.resource-ref:hover {
  background-color: #555;
  color: #ffffff;
}

pre code {
  background-color: #f5f7fa;
  color: #1a1a1a;
  border-left: 4px solid #4a90e2;
  padding: 0.75em;
  display: block;
  border-radius: 6px;
  font-size: 0.9em;
  line-height: 1.4em;
}
pre code:hover {
  background-color: #dce1e8;
  border-left-color: #28527a;
}
.lab-card {
  margin: 0 0 1rem 0;
  border-radius: 0.75rem;
  border: 1px solid #ddd;
  background: #fff;
  padding: 0.25rem 0.75rem 0.75rem;
}

.lab-card > summary {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  list-style: none;
  cursor: pointer;
  padding: 0.5rem 0;
  font-weight: 600;
}

.lab-card > summary::-webkit-details-marker {
  display: none; /* hide default arrow in some browsers */
}

.lab-card > summary::after {
  content: "‚Ä∫";
  margin-left: auto;
  font-size: 1rem;
  transition: transform 0.15s ease-out;
}

.lab-card[open] > summary::after {
  transform: rotate(90deg);
}

.lab-label {
  font-family: monospace;
  opacity: 0.7;
}

.lab-title {
  font-weight: 700;
}

.lab-tag {
  font-size: 0.8rem;
  padding: 0.1rem 0.4rem;
  border-radius: 999px;
  border: 1px solid #ccc;
  background: #fff;
}

.lab-body {
  border-top: 1px solid #e0e0e0;
  margin-top: 0.25rem;
  padding-top: 0.5rem;
}

details.hint {
  margin-top: 0.5rem;
  padding: 0.5rem;
  background: #f9f9f9;
  border-left: 3px solid #aaa;
}

details.hint > summary {
  cursor: pointer;
  font-weight: 500;
  color: #555;
}
  </style>
</head>
<body>
  <div id="header">
    <a id="index_link" href="../index.html">CSSE 220</a>
    <a id="syllabus_link" href="../syllabus.html">Syllabus</a>
    <a id="schedule_link" href="../schedule.html">Schedule</a>
    <a id="quiz_link" href="./design-principles.html">Design</a>
    <a id="quiz_link" href="../labs.html">Labs</a>
    <a id="quiz_link" href="../homework.html">Homework</a>
    <a id="quiz_link" href="../exams.html">Exams</a>
    <a id="quiz_link" href="../project.html">Final Project</a>
    <a id="resources_link" href="../resources.html">Resources</a>
    <div style="clear:both;"></div>
</div>
<section id="content">
<!-- <div id="content"> -->
    <h1>Lab Assignment 17</h1>
    <nav id="lab-nav">
        <ul>
          <li><a href="#lab1">01. Collision</a></li>
          <li><a href="#lab2">02. ImageIO (Sprites)</a></li>

          <!-- Add more lab links as needed -->
        </ul>
      </nav>
<!-- Lab Navigation Menu -->
<!-- <div id="main-content"> -->
 <!-- <section>
  <p>Resources 1: <a href="../resources.html#events" target="_blank" class="resource-ref">Events</a></p>
  <p>Resources 2: <a href="../resources.html#listener" target="_blank" class="resource-ref">Understanding Listener with getActionCommand()</a></p>
  <p>Resources 3: <a href="../resources.html#focus" target="_blank" class="resource-ref">How to keep focus on Frame for events</a></p>

</section>-->
<!-- <p>Submission: 1) BallModel, GameComponent, Ball</p> -->
<!-- <div id="main-content">

    <div class="lab-section" id="lab1"> -->
<!-- </section> -->


  <div class="lab-section" id="lab1">
  <h2>01. Ball Collision</h2>
 
<ol>
<li>Use the same project you built for Lab16</li>

<!-- <li>
Download <a href="./tennis.png" target="_blank" class="resource-ref"><code>tennis.png</code></a> and place it in the
<b>same package</b> as <code>Ball.java</code> (same folder in <code>src</code>).
</li> -->
</ol>


</div>
<!-- STEP 1 -->
<details class="lab-card">
<summary>1Ô∏è‚É£ Bounce off the walls</summary>
<p>
<p>
Before we add sprites or multiple balls, we want a <b>clean, simple way</b>
to say: ‚Äúthis object knows how to bounce inside a rectangle.‚Äù
</p>


<p>
We‚Äôll do that with a <b>very small interface</b>.
</p>
<p>
Right now, <code>Ball.move()</code> only updates position:
</p>


<pre><code class="language-java">public void move() {
x += dx;
y += dy;
}</code></pre>


<p>
That‚Äôs intentional, the <code>Ball</code> does not know how big the window is.
Bouncing depends on the <b>world</b>, not just the object.
</p>


<p>
So instead of hard-coding screen size into <code>Ball</code>,
we define a rule:
</p>


<blockquote>
‚ÄúAny object that can collide with the screen must know how to
update itself <b>given</b> the screen size.‚Äù
</blockquote>

<p>
Create a new interface called <code>Collidable</code>.
It has <b>one method</b>. That‚Äôs it.
</p>


<pre><code class="language-java">public interface Collidable {
void update(int worldWidth, int worldHeight);
}</code></pre>


<p>
This method answers one question:
</p>
<p>
<b>‚ÄúGiven the size of the world, how should this object move and bounce?‚Äù</b>
</p>
</details>
</details>
<details class="lab-card">
<summary>2Ô∏è‚É£ Make <code>Ball</code> implement <code>Collidable</code></summary>


<p>
Now the <code>Ball</code> agrees to that contract.
It still moves simply but now it also handles bouncing.
</p>


<pre><code class="language-java">public class Ball implements Collidable {
@Override
public void update(int worldWidth, int worldHeight) {
// move first
x += dx;
y += dy;


int diameter = radius * 2;


// Left wall
if (x < 0) {
x = 0; // clamp
dx = -dx;
}
// Right wall
else if (x + diameter > worldWidth) {
x = worldWidth - diameter;
dx = -dx;
}


// Top wall
if (y < 0) {
y = 0;
dy = -dy;
}
// Bottom wall
else if (y + diameter > worldHeight) {
y = worldHeight - diameter;
dy = -dy;
}
}
}</code></pre>
</details>


<details class="lab-card">
<summary>3Ô∏è‚É£ Call <code>update</code> from the component (one line!)</summary>


<p>
In your animation loop (timer), updating a ball now looks like this:
</p>


<pre><code class="language-java">ball.update(WIDTH, HEIGHT);
repaint();</code></pre>


<p>
That‚Äôs it. The component knows the world size.
The ball knows how to behave inside it.
</p>

<p>
In our game drawing component, let's define the world size as constants variables. Also adjust <code>private int dy = 4; // </code>
</p>


<pre><code class="language-java">public class DrawingComponent extends JPanel {
public static final int WIDTH = 500;
public static final int HEIGHT = 200;


public DrawingComponent() {
setPreferredSize(new Dimension(WIDTH, HEIGHT));
}
}</code></pre>
</details>


<div class="lab-section" id="lab2">

<h2>02. Add a Sprite (Image)</h2>
<ol>


<li>
Download <a href="./tennis.png" target="_blank" class="resource-ref"><code>tennis.png</code></a>
</li>
  <li>Place <code>tennis.png</code> in the <b>same package</b> as <code>Ball.java</code></li>
  <li>Load with <code>ImageIO.read(Ball.class.getResource("tennis.png"))</code></li>
  <li>Try/Catch: if loading fails, draw a circle so the game still works</li>
</ol>
</div>
<details class="lab-card">
  <summary>1Ô∏è‚É£  Load the sprite (once) inside <code>Ball</code></summary>
We do <b>not</b> want to reload the image for every ball object.
Instead, we store it in a <b>static</b> field and load it once the first time any ball is created.
</p>


<ol>
<li>Open <code>Ball.java</code>.</li>
<li>Add two static fields: <code>sprite</code> and <code>triedLoad</code>.</li>

<!-- </ol> -->


<pre><code class="language-java">public class Ball implements Collidable {

// ‚úÖ sprite cache (shared by ALL balls)
private static BufferedImage sprite = null;
private static boolean triedLoad = false;
</code></pre>
<details class="hint">
<summary>What is a <code>BufferedImage</code>?</summary>


<p>
A <code>BufferedImage</code> is Java‚Äôs way of storing an image
<b>fully loaded into memory</b>.
</p>


<ul>
<li>‚ÄúBuffered‚Äù = the pixel data is already available</li>
<li>‚ÄúImage‚Äù = something Java can draw on the screen</li>
</ul>


<p>
Once an image is a <code>BufferedImage</code>, Java can:
</p>
<ul>
<li>draw it quickly every frame</li>
<li>resize it when drawing</li>
<li>read or modify individual pixels (advanced)</li>
</ul>


<p>
In this lab, <code>ImageIO.read(...)</code> loads <code>tennis.png</code>
and turns it into a <code>BufferedImage</code> so we can draw it with
</p>
</details>
<!-- <ol> -->
<li>Add a helper method <code>loadSpriteOnce()</code> and call it in the constructor.</li>
    </ol>
<pre><code class="language-java">
private static void loadSpriteOnce() {
if (triedLoad) return;
triedLoad = true;

try {
// tennis.png must be in the SAME package as Ball.java
sprite = ImageIO.read(Ball.class.getResource("tennis.png"));
} catch (IOException | IllegalArgumentException ex) {
sprite = null; 
}
}
}</code></pre>

<pre><code>

public Ball(int x, int y) {
this.x = x;
this.y = y;
loadSpriteOnce();
}


</code></pre>

<h4>What each part does</h4>


<ul>
<li>
<code>sprite</code><br>
Stores the actual image data in memory.
It is <b>static</b>, so <em>all</em> Ball objects share the same image.
</li>


<li>
<code>triedLoad</code><br>
Remembers whether we already attempted to load the image.
This prevents trying to reload the file every time a new ball is created.
</li>
</ul>


<h4>Inside <code>loadSpriteOnce()</code></h4>


<ol>
<li>
<code>if (triedLoad) return;</code><br>
If we already tried loading the image earlier, stop immediately.
No work is repeated.
</li>


<li>
<code>triedLoad = true;</code><br>
Mark that we are now attempting the load.
Even if loading fails, we won‚Äôt keep retrying every frame.
</li>


<li>
<code>ImageIO.read(...)</code><br>
Reads <code>tennis.png</code> from the same package as <code>Ball.java</code>
and loads it into memory as a <code>BufferedImage</code>.
</li>


<li>
<code>catch (...)</code><br>
If the image is missing or unreadable,
we safely fall back to drawing a circle instead.
</li>
</ol>


<details class="hint">
<summary>üí° Why not load the image inside <code>draw()</code>?</summary>
<p>
<code>draw()</code> runs many times per second.
Loading an image there would be extremely slow.
This helper ensures loading happens once, up front.
</p>
</details>


<details class="hint">
<summary>üí° Why is this method <code>static</code>?</summary>
<p>
The image belongs to the <b>class</b>, not to any single ball.
Every ball uses the same sprite, so we store and load it once.
</p>
</details>
</details>

<details class="lab-card">
<summary>2Ô∏è‚É£ How the sprite replaces the red circle</summary>


<p>
Your ball used to be drawn like this:
</p>


<pre><code class="language-java">g2.setColor(Color.RED);
g2.fillOval(x, y, diameter, diameter);</code></pre>


<p>
That code <b>always</b> draws a red circle.
To replace it with a sprite, we must decide:
</p>


<blockquote>
‚ÄúDo we have an image loaded?
If yes ‚Üí draw the image.
If no ‚Üí fall back to the circle.‚Äù
</blockquote>


<h4>‚úÖ The key idea</h4>
<p>
The sprite does not automatically replace the circle.
<b>Your <code>draw</code> method decides what gets drawn.</b>
</p>


<h4>The updated <code>draw</code> method</h4>


<pre><code class="language-java">public void draw(Graphics2D g2) {
int diameter = radius * 2;


if (sprite != null) {
// sprite replaces the circle
g2.drawImage(sprite, x, y, 2*radius, 2*radius, null);
} else {
// fallback if sprite failed to load
g2.setColor(Color.RED);
g2.fillOval(x, y, 2*radius, 2*radius);
}
}</code></pre>


<h4>What‚Äôs happening here (step by step)</h4>
<ol>
<li>
We check <code>sprite != null</code>
<br>
‚Üí This means the image loaded successfully.
</li>
<li>
If true, we call <code>drawImage</code>
<br>
‚Üí The sprite is drawn instead of the circle.
</li>
<li>
If false, we draw the red circle
<br>
‚Üí The program still works even without the image.
</li>
</ol>


<details class="hint">
<summary>üí° Why do we keep the red circle code?</summary>
<p>
It‚Äôs a safety net.
If the image path is wrong or the file is missing,
the game still runs and you can debug visually.
</p>
</details>


<h4>‚úÖ Final result</h4>
<ul>
<li>Sprite loaded ‚Üí red circle is <b>not drawn</b></li>
<li>Sprite missing ‚Üí red circle appears instead</li>
</ul>


<p>
You didn‚Äôt ‚Äúdelete‚Äù the circle.
You made the sprite <b>override it</b> by drawing first.
</p>
</details>


</section>


</body>
</html>