<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>CSSE 220</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
<link rel="stylesheet" type="text/css" href="../syllabus_files/schedule.css">
<link rel="stylesheet" type="text/css" href="../syllabus_files/screen.css">
<style>

body {
          font-family: Arial, sans-serif;
          line-height: 1.5;
          margin: 0;
          padding: 1rem;
          background: #f5f7fa;
          color: #333;
        }
        
        /* Section containers */
        section {
          background: #fff;
          border: 1px solid #ddd;
          border-radius: 6px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.05);
          margin: 1.5rem 0;
          padding: 1.2rem;
        }
        
        /* Headings */
        h2 {
          margin-top: 0;
          font-size: 1.6rem;
          border-bottom: 2px solid #e0e0e0;
          padding-bottom: 0.3rem;
        }
        h3 {
          font-size: 1.3rem;
          margin-top: 1rem;
        }
        
        /* Image styling */
        section img {
          display: block;
          max-width: 100%;
          height: auto;
          margin: 0.8rem auto;
          border: 1px solid #ccc;
          border-radius: 4px;
        }
        
        /* Code blocks */
        /* pre {
          background: #2d2d2d;
          color: #f8f8f2;
          padding: 0.8rem;
          border-radius: 1px;
          overflow-x: auto;
          font-family: "Courier New", Courier, monospace;
          font-size: 0.9rem;
        } */
        /* pre code {
          display: block;
          white-space: pre-wrap;
          word-wrap: break-word;
        } */
        
        /* Inline code */
        /* code {
          background: #eaeaea;
          color: #c7254e;
          padding: 0.2rem 0.4rem;
          border-radius: 1px;
          font-family: "Courier New", Courier, monospace;
          font-size: 0.95em;
        } */
        
        /* Highlight compile / runtime state */
        strong + span {
          font-weight: bold;
          color: #d14;
        }
        
        /* Lists */
        ul, ol {
          margin: 0.5rem 0 0.5rem 1.2rem;
        }
        li {
          margin-bottom: 0.5rem;
        }
        
        /* Method call subsections */
        section#method-calls h4 {
          margin: 1rem 0 0.3rem;
          font-size: 1.1rem;
          color: #444;
          border-left: 3px solid #007acc;
          padding-left: 0.5rem;
        }
        
        /* Emphasis for compile/run status */
        span[style*="darkred"] {
          font-weight: bold;
          color: #c00;
        }



    /* body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f5f5f5;
    } */
    #main-content {
      padding: 20px;
    }
/* Header styling */
#header {
        position: fixed;
        top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
    }
    #header a {
      color: #fff;
      margin-right: 15px;
      text-decoration: none;

    }
    #header a:hover {
      text-decoration: underline;
    }
    #header div {
      clear: both;
    }
    /* Content container */
    #content {
      padding: 20px;
      /* margin-top: 100px;  */
      margin-bottom: 50px;
      padding-top: 100px;
    }
    #section {
margin-top: 1rem; 
margin-bottom: 1rem;
padding: 20px;
} 
    .lab-section {
      background-color: #fff;
      border: 1px solid #ccc;
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 5px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
    }
    .lab-section h2 {
      border-bottom: 2px solid #ddd;
      padding-bottom: 5px;
      color: #333;
    }
    .lab-section p {
      line-height: 1.5;
      color: #555;
    }
/* Lab Navigation Menu Styling */
#lab-nav {
      background-color: #faf9fc;
      padding: 10px;
      margin-bottom: 20px;
      border: 1px solid #ccc;
      border-radius: 5px;
      overflow-x: auto;  /* Enables horizontal scroll */
      white-space: nowrap; /* Prevents wrapping */
    }
    #lab-nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
      display: flex;
      gap: 15px;
    }
    #lab-nav ul li a {
      text-decoration: none;
      color: #333;
      margin-left: 20px;
      padding: 5px 10px;
      border-radius: 3px;
    }
    #lab-nav ul li a:hover {
      background-color: #ddd;
    }
    code {
        color: red;
    }
    .code-window {
      background-color: #272822;
      color: #f8f8f2;
      border: 1px solid #333;
      padding: 10px;
      font-family: Consolas, "Courier New", monospace;
      white-space: pre;
      overflow-x: auto;
      border-radius: 3px;
      margin-top: 10px;
    }
    .solution-window {
      background-color: #e8f5e9;
      color: #2e7d32;
      border: 1px solid #4caf50;
      padding: 10px;
      font-family: Consolas, "Courier New", monospace;
      border-radius: 3px;
      overflow-x: auto;
      white-space: pre;
      margin-top: 10px;
    }
    .solution-header {
      font-weight: bold;
      margin-bottom: 5px;
      color: #2e7d32;
    }

    a.resource-ref {
  background-color: #444; /* dark background for contrast */
  color: #61dafb;         /* bright text color */
  padding: 4px 8px;
  border-radius: 4px;
  text-decoration: none;
  transition: background-color 0.2s ease;
}

a.resource-ref:hover {
  background-color: #555;
  color: #ffffff;
}

pre code {
  background-color: #f5f7fa;
  color: #1a1a1a;
  border-left: 4px solid #4a90e2;
  padding: 0.75em;
  display: block;
  border-radius: 6px;
  font-size: 0.9em;
  line-height: 1.4em;
}
pre code:hover {
  background-color: #dce1e8;
  border-left-color: #28527a;
}
.lab-card {
  margin: 0 0 1rem 0;
  border-radius: 0.75rem;
  border: 1px solid #ddd;
  background: #fff;
  padding: 0.25rem 0.75rem 0.75rem;
}

.lab-card > summary {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  list-style: none;
  cursor: pointer;
  padding: 0.5rem 0;
  font-weight: 600;
}

.lab-card > summary::-webkit-details-marker {
  display: none; /* hide default arrow in some browsers */
}

.lab-card > summary::after {
  content: "‚Ä∫";
  margin-left: auto;
  font-size: 1rem;
  transition: transform 0.15s ease-out;
}

.lab-card[open] > summary::after {
  transform: rotate(90deg);
}

.lab-label {
  font-family: monospace;
  opacity: 0.7;
}

.lab-title {
  font-weight: 700;
}

.lab-tag {
  font-size: 0.8rem;
  padding: 0.1rem 0.4rem;
  border-radius: 999px;
  border: 1px solid #ccc;
  background: #fff;
}

.lab-body {
  border-top: 1px solid #e0e0e0;
  margin-top: 0.25rem;
  padding-top: 0.5rem;
}

details.hint {
  margin-top: 0.5rem;
  padding: 0.5rem;
  background: #f9f9f9;
  border-left: 3px solid #aaa;
}

details.hint > summary {
  cursor: pointer;
  font-weight: 500;
  color: #555;
}
  </style>
</head>
<body>
  <div id="header">
    <a id="index_link" href="../index.html">CSSE 220</a>
    <a id="syllabus_link" href="../syllabus.html">Syllabus</a>
    <a id="schedule_link" href="../schedule.html">Schedule</a>
    <a id="quiz_link" href="../worksheets.html">Quizzes</a>
    <a id="quiz_link" href="../labs.html">Labs</a>
    <a id="quiz_link" href="../homework.html">Homework</a>
    <a id="quiz_link" href="../exams.html">Exams</a>
    <a id="quiz_link" href="../project.html">Final Project</a>
    <a id="resources_link" href="../resources.html">Resources</a>
    <div style="clear:both;"></div>
</div>
<div id="content">
<!-- <div id="content"> -->
    <h1>Lab Assignment 20</h1>
    <!-- <nav id="lab-nav">
        <ul>
          <li><a href="#lab1">01. Refactor Timer</a></li>
          <li><a href="#lab2">02. HUD / save files</a></li>

      
         

        </ul>
      </nav> -->
<!-- Lab Navigation Menu -->
<!-- <div id="main-content"> -->
 <!-- <section>
  <p>Resources 1: <a href="../resources.html#events" target="_blank" class="resource-ref">Events</a></p>
  <p>Resources 2: <a href="../resources.html#listener" target="_blank" class="resource-ref">Understanding Listener with getActionCommand()</a></p>
  <p>Resources 3: <a href="../resources.html#focus" target="_blank" class="resource-ref">How to keep focus on Frame for events</a></p>

</section>-->

<div id="main-content">
<div class="lab-section" id="lab1">
<h2>Lab 20: Multiple Objects + Object Collisions</h2>

<div class="lab-summary">
  <p>
    In this lab, you‚Äôll level-up your game engine by managing <b>multiple objects</b>
    and handling <b>collisions between objects</b> (not just walls).
  </p>

  
</div>

<details class="lab-card" open>
  <summary>Design Rule: Who is responsible for what?</summary>

  <p>
    As we add more objects and collisions, it‚Äôs important to be clear about
    <b>which class owns which responsibility</b>.
    This prevents duplicated logic and keeps Milestone 2 manageable.
  </p>

  <table class="summary-table">
    <tr>
      <th>Responsibility</th>
      <th>Class that owns it</th>
    </tr>

    <tr>
      <td>Move the ball each frame</td>
      <td><code>Ball</code></td>
    </tr>

    <tr>
      <td>Handle wall collisions (bounce off edges)</td>
      <td><code>Ball</code> (<code>update(worldWidth, worldHeight)</code>)</td>
    </tr>

    <tr>
      <td>Know the world size</td>
      <td><code>DrawingComponent</code></td>
    </tr>

    <tr>
      <td>Ball vs Ball collisions</td>
      <td><code>DrawingComponent</code></td>
    </tr>

    <tr>
      <td>Ball vs Collectible collisions</td>
      <td><code>DrawingComponent</code></td>
    </tr>

    <tr>
      <td>Making a collectible disappear</td>
      <td><code>DrawingComponent</code></td>
    </tr>

  
  </table>

  
</details>

<details class="lab-card">
  <summary><strong>Step 1:</strong> Refactor Level Loading</summary>

  <p>Move your current <code>Scanner</code> logic that reads <code>level1.txt</code> into a method:</p>

      <pre><code>private void loadLevel() {
    File file = new File("level1.txt");
  // your code block with try / catch ....

</code></pre>
<h4>2Ô∏è‚É£ Call <code>loadLevel()</code> in your constructor</h4>
  <p>
    Call this method <strong>before</strong> creating the ball:
  </p>
<pre><code>
  loadLevel();
		ball = new Ball(startX,startY,14);
  </code></pre>


  <h4>3Ô∏è‚É£ Add new Required fields</h4>
  <p>
    Your class should already have these fields + add enemies :
  </p>

  <pre><code>private int startX = 80;
private int startY = 100;
private ArrayList&lt;Ball&gt; enemies = new ArrayList&lt;&gt;();</code></pre>

<h4>4Ô∏è‚É£ Extend <code>loadLevel()</code> to support enemies</h4>
  <p>
    Update your <code>loadLevel()</code> method by adding an additional
    <code>if</code> statement:
  </p>

  <ul>
    <li><code>'P'</code> ‚Üí player spawn (one)</li>
    <li><code>'E'</code> ‚Üí enemy spawn (many)</li>
  </ul>

  <pre><code>    if (c == 'P') {
	                	//System.out.println(c);
	                	startX = col * TILE_SIZE;
	                	startY = row * TILE_SIZE;
	                 
	                } else if (c == 'E') {
	                    enemies.add(new Ball(col * TILE_SIZE, row * TILE_SIZE, 14));
	                }</code></pre>

  <p>
    Each <code>'E'</code> in the file should create a new enemy object.
  </p>

  <h4>Update <code>level1.txt</code></h4>
  <p>
    Add several <code>'E'</code> characters to represent enemies:
  </p>

  <pre><code>##########
#P....E..#
#..E.....#
#.....E..#
##########</code></pre>
    

    <li>
      Create the player <strong>after</strong> calling <code>loadLevel()</code>, so it uses the coordinates found in the file.
    </li>

    <li>
      Store enemies in a collection (ex: <code>ArrayList&lt;Ball&gt;</code>) so your game can support multiple enemies.
    </li>
  </ol>

  <details class="hint">
    <summary>Hint</summary>
    <p>
      One player needs one <code>(x, y)</code>.  
      Many enemies need a list of objects.
    </p>
  </details>

</details>


<details class="lab-card">
  <summary><strong>Step 2:</strong> Add Enemies to the Game - DrawingComponent</summary>
  <p>
    Now that your level loader supports enemies, update
    <code>DrawingComponent</code> to manage and draw them.
  <h4>Draw all enemies</h4>
  <p>
    In <code>paintComponent</code>, draw the player first, then loop through
    the enemies and draw each one.
  </p>

  <pre><code>// draw player
ball.draw(g2);

// draw enemies
for (Ball enemy : enemies) {
    enemy.draw(g2);
}</code></pre>

  <h4>Move enemies</h4>
  <p>
    Update enemies movements in the same timer
  </p>

  <pre><code>for (Ball enemy : enemies) {
    enemy.update(); // movement + wall collision
}</code></pre>



</details>



</details>

<details class="lab-card">
  <summary><strong>Step 3:</strong> Add a Collision Box and Intersect</summary>

  <h4>Goal</h4>
  <p>
    Every moving object (player and enemies) needs a collision box
    so we can detect when objects touch.
  </p>
  <p>
  For this lab, both the player and enemies are <code>Ball</code> objects,
  so the <code>getBounds()</code> method only needed once in <code>Ball.java</code>.
</p>

  <h4>1Ô∏è‚É£ Open <code>Ball.java</code></h4>
  <p>
    Add the following method to your <code>Ball</code> class:
  </p>

  <pre><code>public Rectangle getBounds() {
    Rectangle r = new Rectangle(
			    x - radius,
			    y - radius,
			    radius * 2,
			    radius * 2
    );
    return r;
}</code></pre>


<h4>2Ô∏è‚É£  <code>intersects()</code></h4>
  <p>
    <code>intersects()</code> is a method provided by Java‚Äôs <code>Rectangle</code> class.
    It checks whether two rectangles overlap.
  </p>

  <h4>How we use it</h4>
  <p>
    Since each object now has a collision box (<code>getBounds()</code>),
    we can detect collisions like this:
  </p>

  <pre><code>Rectangle r1 = enemy1.getBounds();
Rectangle r2 = enemy2.getBounds();

if (r1.intersects(r2)) {
    // collision happened
}</code></pre>
  

  <details class="hint">
    <summary>Why are we using rectangles?</summary>
    <p>
      Rectangles are simple, fast, and built into Java.
      If two rectangles overlap, we treat it as a collision.
    </p>
  </details>

</details>

<details class="lab-card">
  <summary><strong>Step 4:</strong> Enemy‚ÄìEnemy Collision (Bounce / Reverse Direction)</summary>

  <h4>1Ô∏è‚É£ Add or update <code>flip()</code> to <code>Ball</code></h4>
  <pre><code>public void flip() {
    dx = -dx;
    dy = -dy;
}</code></pre>

  <h4>2Ô∏è‚É£ Add enemy‚Äìenemy collision checks inside the Timer</h4>
  <p>
    After updating all enemies, check each pair of enemies
    to see if they collide.
    If they do, call <code>flip()</code> on both enemies.

  <pre><code>// update enemies
for (Ball enemy : enemies) {
    enemy.update(WIDTH, HEIGHT);
}

// enemy-enemy collisions (nested loop)
for (int i = 0; i &lt; enemies.size(); i++) {
    for (int j = i + 1; j &lt; enemies.size(); j++) {
        Ball e1 = enemies.get(i);
        Ball e2 = enemies.get(j);

        if (e1.getBounds().intersects(e2.getBounds())) {
            e1.flip();
            e2.flip();
        }
    }
}</code></pre>

  <details class="hint">
    <summary>Why does <code>j</code> start at <code>i + 1</code>?</summary>
    <p>
      So you don‚Äôt compare an enemy with itself, and you don‚Äôt check the same pair twice.
    </p>
  </details>
</details>
<details class="lab-card">
  <summary><strong>Step 5:</strong> Player‚ÄìEnemy Collision (Enemy Disappears)</summary>

  <p>
    When the player collides with an enemy, remove the enemy from the game.
  </p>

  <h4>Inside the Timer</h4>
  <pre><code>for (int i = 0; i &lt; enemies.size(); i++) {
    if (ball.getBounds().intersects(enemies.get(i).getBounds())) {
        enemies.remove(i);
        break; // remove only one enemy per frame
    }
}</code></pre>

<details class="hint">
  <summary>ConcurrentModificationException Danger</summary>
  <p>
    Removing elements from an <code>ArrayList</code> inside a for-each loop
    causes a <code>ConcurrentModificationException</code>.
  </p>
  <p>
    An index-based loop is safe because you control the index yourself.
    After removing one enemy, the <code>break</code> statement stops the loop.
  </p>
</details>

</details>
</details>

    </div>
<!-- <div class="lab-section" id="lab2">
<h2>02. Create HUD model and HUD viewer</h2>


<pre><code class="language-java">public class HudModel {

	
	private int score = 0;
    private int ballCount = 0;

    public int getScore() { return score; }
    public int getBallCount() { return ballCount; }
    
    public void addScore(int delta) { 
    	this.score +=delta; 
    	}
    public void setBallCount(int count) { 
    	this.ballCount = count; 
    	}
}
</code></pre>
<p>Note - we are using some HTML tags and combine them using String Builder</p>
<pre><code>public class HudView extends javax.swing.JLabel {
public HudView() {
setOpaque(false);
setForeground(new java.awt.Color(230,240,255));
setFont(getFont().deriveFont(java.awt.Font.BOLD, 13f));
}
public void refresh(HudModel hud) {
StringBuilder html = new StringBuilder("<html><h2 style='margin:0'>Score</h2><ol>");
html.append("<li>Current: ").append(hud.getScore()).append("</li>");
html.append("<li>Balls: ").append(hud.getBallCount()).append("</li>");
html.append("</ol></html>");
setText(html.toString());
}
}
  </code></pre>
<p>Add HUD to GamePanel using Overlay Layout</p>
<p>Since HudView is a JLabel, you just layer it on top of the game canvas</p>
<pre><code>private final HudModel hudModel = new HudModel();
private final HudView hudView = new HudView();


public GamePanel() {
setLayout(new BorderLayout());


JPanel layered = new JPanel();
layered.setLayout(new OverlayLayout(layered));
layered.setOpaque(false);


canvas.setOpaque(true);
layered.add(canvas); // back


hudView.setOpaque(false);
hudView.setAlignmentX(0f); // left
hudView.setAlignmentY(0f); // top
hudView.setBorder(javax.swing.BorderFactory.createEmptyBorder(8,8,0,0));
layered.add(hudView); // top


add(layered, BorderLayout.CENTER);
add(buildControls(), BorderLayout.SOUTH);


// initial sync
hudModel.setBallCount(ballModel.getBallCount());
hudView.refresh(hudModel);</code></pre>

<p>Update tick()</p>
<pre><code class="language-java">private void tick() {
  ballModel.updateAll(canvas.getWidth(), canvas.getHeight());
  hudModel.setBallCount(ballModel.getBallCount());
  hudView.refresh(hudModel);
  canvas.repaint();
}</code></pre>  
 <p>Update GameComponent. So GamePanel will create Models now but GameComponent only view them. So we will pass them as parameteres in constructor</p>
<pre><code>	private final BallModel model;
	private final HudModel hud;
	public GameComponent(BallModel model, HudModel hud) {
		this.setPreferredSize(new Dimension(WIDTH,HEIGHT));
		//  seed a couple so something is visible immediately
	    this.model = model;
	    this.hud = hud;
	    setOpaque(true);   
	}
  </code></pre>
  <p>Update Game Component constructor in GamePanel:</p>
  <pre><code>private final GameComponent canvas = new GameComponent(ballModel,hudModel);</code></pre>
  <p>Update the GAmePanel</p>
  <pre><code>public GamePanel() {
    	JPanel layered = new JPanel();
        layered.setLayout(new OverlayLayout(layered));
        layered.setOpaque(false);  // Make layered panel transparent
        // view
        canvas.setOpaque(false); // panels sets the background if you want it from canvas, set it to true
        layered.add(hudView); 
    	layered.add(canvas);
    	layered.add(canvas);

    	hudView.setOpaque(false);         // Transparent so no gray background
    	hudView.setAlignmentX(0f);        // Left edge
    	hudView.setAlignmentY(0f);        // Top edge
    	layered.add(hudView);             // Add after canvas ‚Üí goes on top
       
    	// PANEL LAYOUT
    	this.setLayout(new BorderLayout());
    	this.add(layered, BorderLayout.CENTER);
    	this.setBackground(canvas.BG);
    	this.add(buildControls(), BorderLayout.SOUTH);</code></pre>
  
  
      
<div class="lab-section" id="lab3">
<h2>03. Score Manager</h2>
<p>Create a score manager with 2 helper functions to save and load score. Create a folder in yoru Java Project named data (it should be not inside src but a the same level)</p>

<pre><code>public class ScoreManager {

	
	private static final String FILE = "data/scores.txt";
	
	public static void save(int score, int balls) {
        try (PrintWriter out = new PrintWriter(new FileWriter(FILE, true))) {
            out.println(score + "," + balls + "," + System.currentTimeMillis());
        } catch (IOException e) {
            e.printStackTrace(); // or show a dialog if you prefer
        }
    }
	
	public static List<String> load() {
        List<String> lines = new ArrayList<>();
        File f = new File(FILE);
        if (!f.exists()) return lines;

        try (BufferedReader br = new BufferedReader(new FileReader(f))) {
            String line;
            while ((line = br.readLine()) != null) {
                lines.add(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return lines;
    }
	
}</code></pre>
<p>Add a key to save the text in GamePanel</p>
<pre><code>case KeyEvent.VK_S -> {
	                    ScoreManager.save(hudModel.getScore(), hudModel.getBallCount());
	                    // quick feedback (optional)
	                    System.out.println("Saved: score=" + hudModel.getScore() + ", balls=" + hudModel.getBallCount());
	                }</code></pre>


<h2>üß™ Checkpoints</h2>
<ul>
  <li>Refactor compiles; timer animates.</li>
  <li>Score is saved in the fileSprite when pressing S key</li>
  <li>Score is shown as overlay</li>
  
</ul>
<p>The refactored code is available here: <a href="./BallHud.zip">Unzip or import to Eclipse</a></p>
</div>-->

</body>
</html>